/*
    Copyright (C) 2005  Erdal Mutlu

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
*/

/*
Cache:
	- system  : id, name, fullname, enabled, status related info (systemstatus and systemservicestatus tables)
	- service : id, name
	- sync of the cache with the db : 1) periodically 2) on request

system status			: system id -> status
system status change time 	: system id -> change time 
system status update time	: system id -> update time
max status for a system		: system id -> max status
error_warning message for a system: system id -> error_warning message
*/

/*
#ifdef HAVE_CONFIG_H
	#include"config.h"
#endif
*/

#include<iostream>
#include<pthread.h>
#include<fstream>
#include<syslog.h>
#include<list>
#include<string>
#include<sstream>

// this is a C++ program
#ifndef __cplusplus
#define __cplusplus
#endif

#include"common.hpp"
/*
 Declare all C function with
	BEGIN_C_DECLS
	C function list
	END_C_DECLS
*/

#include<errno.h>
#include<sys/times.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<sys/stat.h>
#include<sys/socket.h>
#include<sys/poll.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<signal.h>
#include<setjmp.h>

#include<error.h>
#include<string.h>

#include"misc.h"

#include"ConfFile.hpp"
#include"UpperLowerCase.hpp"
#include"trim.hpp"
#include"stringtok.hpp"
#include"stringConvert.hpp"

#include"Connection.hpp"
#include"DriverManager.hpp"
#include"ResultSet.hpp"
#include"SQLException.hpp"
#include"Statement.hpp"

#include"SisIYAMessage.hpp"

/*
BEGIN_C_DECLS
END_C_DECLS
*/
// backlog value for listen()
#define LISTENQ 20

using namespace std;

//! The name of the configuration file.
char *confFileName;

//! Coonection object
//Connection *conn=NULL;

//! DriverManager object
DriverManager *dm;

//! The name of the program.
char *pname;

//! Configuration file object.
ConfFile confFile;

//! The process ID of the server process
pid_t serverPID;

//! loglevel variable, change the code to use confFile.getInt("LOGLEVEL")
int loglevel;

//! Listening socket
int listenfd;

//! The server and client socketaddr structures
struct sockaddr_in cli_addr, serv_addr;

//! The max string buffer
static const int MAX_STR = 4096;

//! Id of the cacheManager thread.
pthread_t cacheManagerID;

//! Id of the networkManager thread.
pthread_t networkManagerID;

//! Number of dbWriter threads.
int nDBWriters;

//! An array of ids of dbWriter threads.
//pthread_t **dbWriterIDs;
pthread_t dbWriterIDs[100];

//! The status ids
static const int MESSAGE_INFO = 0;
static const int MESSAGE_OK = 1;
static const int MESSAGE_WARNING = 2;
static const int MESSAGE_ERROR = 3;

// defined in include/config.h generated by autoconf/automake #define RETSIGTYPE void


//! A queue of SisIYA messages, This queue is used to collect messages and afterwards to insert them into the DB
list < SisIYAMessage > mqueue;

//! A mutex to protect the queue which contains the SisIYA messages
pthread_mutex_t mqueueMutex = PTHREAD_MUTEX_INITIALIZER;

//! A condition variable for the queue, which contains the SisIYA messages
pthread_cond_t mqueueCond = PTHREAD_COND_INITIALIZER;

//! A mutex to protect the cache which contains information about systems,services and status
pthread_mutex_t cacheMutex = PTHREAD_MUTEX_INITIALIZER;


//! A mutex to protect the ndbconn variable
pthread_mutex_t ndbconnMutex = PTHREAD_MUTEX_INITIALIZER;

//! A condition variable for the ndbconn variable
pthread_cond_t ndbconnCond = PTHREAD_COND_INITIALIZER;

//! A mutex to protect the done variable
pthread_mutex_t doneMutex = PTHREAD_MUTEX_INITIALIZER;

bool done = false;

// The mutex provides mutual exclusion and the conditional variable provides a signaling mechanism.

/*************************************************************************************/
bool blockAllSignals(void);
bool checkServiceID(Connection * conn, int serviceID);
bool checkServiceIDFromCache(int serviceID);
bool checkStatusIDFromCache(int statusID);
void clean_and_exit(int code);
void clean_up(void);
void *cacheManager(void *arg);
void *controlManager(void *);
bool createSignalManager(void);
int daemon_init(void);
void *dbWriter(void *arg);
bool detachThread(pthread_t * tid);
void doit(void);
bool extract_fields(char *msg, int *serviceID, int *statusID,
		    long int *expire, string & hostName, string & str,
		    string & sendTimestamp);
bool checkStatusID(Connection * conn, int statusID);
bool condBroadcast(pthread_cond_t & cond);
bool condSignal(pthread_cond_t & cond);
bool condWait(pthread_cond_t & cond, pthread_mutex_t & mutex);
bool getErrorWarningMessage(Connection * conn, int systemID,
			    string & error_warning);
int getIntValue(Connection * conn, string & sql);
int getSystemID(Connection * conn, string hostName);
int getSystemIDFromCache(string hostName);
bool getSystemUpdateChangeTimes(Connection * conn, int systemID,
				string & updateTime, string & changeTime);
void getTimestamp(string & str);
bool insertMessage(Connection * conn, SisIYAMessage & sm);
bool insertMessage(Connection * conn, long unsigned int systemID,
		   long unsigned int serviceID,
		   short unsigned int statusID, long unsigned int expire,
		   string sendTimestamp, string message);
bool isDone(void);
bool lockMutex(pthread_mutex_t & mutex);
void *networkManager(void *arg);
bool processClient(int connfd);
void sisiya_showconf(void);
void *t_server(void *arg);
bool server(int sfd);
void setDone(bool value);
void *signalManager(void *arg);
bool unlockMutex(pthread_mutex_t & mutex);
bool updateCache(Connection * conn);
bool updateDB(Connection * conn);
bool updateAllSystemStatus(void);
bool updateSystemStatus(Connection * conn, int systemID);

typedef void Sigfunc(int);	/* for signal handlers */
Sigfunc *esignal(int signo, Sigfunc * func);
/***********************************************************************/

/*************************************************************************************/
Sigfunc *esignal(int signo, Sigfunc * func)
{
	struct sigaction act, oact;

	act.sa_handler = func;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
	if (signo == SIGALRM) {
#ifdef  SA_INTERRUPT
		act.sa_flags |= SA_INTERRUPT;	/* SunOS */
#endif
	} else {
#ifdef  SA_RESTART
		act.sa_flags |= SA_RESTART;	/* SVR4, 44BSD */
#endif
	}
	if (sigaction(signo, &act, &oact) < 0)
		return (SIG_ERR);
	return (oact.sa_handler);
}

/*! 
Performs clean up and exits with the specified exit code.
*/
void clean_and_exit(int code)
{
	clean_up();
	if (code != 0)
		syslog(LOG_INFO, "exited with error code=%d", code);
	else
		syslog(LOG_INFO, "exited");

	exit(code);
}

/*! 
Performs clean up.
*/
void clean_up(void)
{
	close(listenfd);
	if (loglevel > 2)
		syslog(LOG_INFO, "closed listenfd %d.", listenfd);
}


/*!
Print the configuration information to syslog.
*/
void sisiya_showconf(void)
{
	syslog(LOG_INFO, "StartServers : [%d]",
	       confFile.getInt("StartServers"));
	syslog(LOG_INFO, "MaxClients : [%d]",
	       confFile.getInt("MaxClients"));
	syslog(LOG_INFO, "MinSpareThreads : [%d]",
	       confFile.getInt("MinSpareThreads"));
	syslog(LOG_INFO, "MaxSpareThreads : [%d]",
	       confFile.getInt("MaxSpareThreads"));
	syslog(LOG_INFO, "ReadTimeout : [%d]",
	       confFile.getInt("ReadTimeout"));
	syslog(LOG_INFO, "PID_FILE : [%s]",
	       confFile.getString("PID_FILE").c_str());
	syslog(LOG_INFO, "LOGLEVEL : [%d]", confFile.getInt("LOGLEVEL"));
	syslog(LOG_INFO, "IP : [%s]", confFile.getString("IP").c_str());
	syslog(LOG_INFO, "PORT : [%d]", confFile.getInt("PORT"));
	syslog(LOG_INFO, "DB_SERVER : [%s]",
	       confFile.getString("DB_SERVER").c_str());
	syslog(LOG_INFO, "DB_TYPE : [%s]",
	       confFile.getString("DB_TYPE").c_str());
	syslog(LOG_INFO, "DB_NAME : [%s]",
	       confFile.getString("DB_NAME").c_str());
	syslog(LOG_INFO, "DB_USER : [%s]",
	       confFile.getString("DB_USER").c_str());
	syslog(LOG_INFO, "DB_PASSWORD : [*******]");
}

/*!
*/
void showConfigs(void)
{
	cout << "StartServers		: [" << confFile.
	    getInt("StartServers") << "]" << endl;
	cout << "MaxClients		: [" << confFile.
	    getInt("MaxClients") << "]" << endl;
	cout << "MinSpareThreads		: [" << confFile.
	    getInt("MinSpareThreads") << "]" << endl;
	cout << "MaxSpareThreads		: [" << confFile.
	    getInt("MaxSpareThreads") << "]" << endl;
	cout << "DBWriterThreads		: [" << confFile.
	    getInt("DBWriterThreads") << "]" << endl;
	cout << "ReadTimeout		: [" << confFile.
	    getInt("ReadTimeout") << "]" << endl;
	cout << "PID_FILE		: [" << confFile.
	    getString("PID_FILE") << "]" << endl;
	cout << "LOGLEVEL		: [" << confFile.
	    getInt("LOGLEVEL") << "]" << endl;
	cout << "IP			: [" << confFile.
	    getString("IP") << "]" << endl;
	cout << "PORT			: [" << confFile.
	    getInt("PORT") << "]" << endl;
	cout << "DB_SERVER		: [" << confFile.
	    getString("DB_SERVER") << "]" << endl;
	cout << "DB_TYPE			: [" << confFile.
	    getString("DB_TYPE") << "]" << endl;
	cout << "DB_NAME			: [" << confFile.
	    getString("DB_NAME") << "]" << endl;
	cout << "DB_USER			: [" << confFile.
	    getString("DB_USER") << "]" << endl;
	cout << "DB_PASSWORD		: [" << confFile.
	    getString("DB_PASSWORD") << "]" << endl;
	cout << "DB_MAX_CONCURRENT_CONNECTIONS	: [" << confFile.
	    getInt("DB_MAX_CONCURRENT_CONNECTIONS") << "]" << endl;
}

void setDefaults(void)
{
	confFile.setDefault("StartServers", 5);
	confFile.setDefault("MaxClients", 600);
	confFile.setDefault("MinSpareThreads", 10);
	confFile.setDefault("MaxSpareThreads", 30);
	confFile.setDefault("DBWriterThreads", 5);
	confFile.setDefault("ReadTimeout", 10);
	confFile.setDefault("PID_FILE", "/var/run/sisiyad.pid");
	confFile.setDefault("LOGLEVEL", 0);
	confFile.setDefault("SEMKEY", 11);
	confFile.setDefault("IP", "any");
	confFile.setDefault("PORT", 8888);
	confFile.setDefault("DB_SERVER", "localhost");
	//confFile.setDefault("DB_TYPE","PostgreSQL");
	confFile.setDefault("DB_TYPE", "MySQL");
	confFile.setDefault("DB_NAME", "sisiya");
	confFile.setDefault("DB_USER", "sisiyauser");
	confFile.setDefault("DB_PASSWORD", "sisiyauser1");
	if (confFile.getString("DB_TYPE") == "PostgreSQL")
		confFile.setDefault("DB_PORT", 5432);
	else if (confFile.getString("DB_TYPE") == "MySQL")
		confFile.setDefault("DB_PORT", 3306);
	else
		confFile.setDefault("DB_PORT", 0);
	confFile.setDefault("DB_MAX_CONCURRENT_CONNECTIONS", 5);
}

/*!
Initialize a daemon process.
*/
int daemon_init(void)
{
	pid_t pid;

	pid = fork();
	if (pid < 0) {
		syslog(LOG_ERR, "could not fork");
		return (-1);
	} else if (pid != 0)
		exit(0);	// the parent exits

	// the 1st child process continues
	pid = setsid();		// become session leader
	if (pid == -1) {
		syslog(LOG_ERR, "cannot set session id");
		exit(1);
	}
	// fork again leaving the child to continue. This is done uarantee that the daemon cannot automatically 
	// acquire a controlling terminal if it opens a terminal device in the future.
	// But before ignore the SIGHUP signal, because when the session leader terminates, all processes in the
	// session are sent the SIGHUP signal.
	if (esignal(SIGHUP, SIG_IGN) == SIG_ERR) {
		syslog(LOG_ERR, "could not set SIGHUP to SIG_IGN.");
		return (-1);
	}
	pid = fork();
	if (pid < 0) {
		syslog(LOG_ERR, "could not fork");
		return (-1);
	} else if (pid != 0)
		exit(0);	// the 1st child continues

	// the 2nd child process continues

	// change working dir to /, so that we do not occupy any mounts
	if (chdir("/") != 0) {
		syslog(LOG_ERR, "cannot change dir to /");
		exit(1);
	}

	umask(0);		// clear our file creation mask, so that any inherited restriction do not apply
	return (0);
};

/*!
Blocks all signals.
*/
bool blockAllSignals(void)
{
	sigset_t set;

	if (sigfillset(&set) == -1) {
		syslog(LOG_ERR,
		       "blockAllSignals: could not fill signal set!");
		return false;
	}
	if (sigprocmask(SIG_BLOCK, &set, NULL) == -1) {
		syslog(LOG_ERR, "blockAllSignals: could set signal mask!");
		return false;
	}
	return true;
}

void doit(void)
{
/*
doit :
init once
	- set default log level
	- daemon_init
	- load driver manager
	- block all signals
	- create signalManager thread
	- getpid
SIGHUP
	- setDefaults and conf file name
	- (re)write the the pid file (pid can be changed in the conf file)
	- (re)create networkManager (port number can be changed in the conf file)
	- (re)create cacheManager thread (the sleep time can be changed in the conf file)
	- (re)create dbWriter threads (the number of dbWriters can be changed in the conf file)
	- block all signals
	- unblock SIGHUP
	- wait for SIGHUP
additional vars:
	- networkManager id
	- an array of dbWriter thread ids and nDBWriters
	- cacheManager thread id
*/

	// set default log level
	loglevel = 0;
	// daemon init
	if (daemon_init() == -1) {
		syslog(LOG_ERR, "could initialize the daemon. Exiting...");
		clean_and_exit(EXIT_FAILURE);
	}
	// load driver manager
	if (dm != NULL)
		delete dm;
	dm = new DriverManager;

	// block all signals
	if (blockAllSignals() == false) {
		syslog(LOG_ERR, "could not block all signals. Exiting...");
		clean_and_exit(EXIT_FAILURE);
	}
	// create signal manager thread, with higher priority
	if (createSignalManager() == false) {
		syslog(LOG_ERR, "Could not create signalManager thread!");
		clean_and_exit(EXIT_FAILURE);
	}
	// get server PID
	serverPID = getpid();



	// set number of dbWriter threads to 0 as an initial value
	nDBWriters = 0;

	// create the control thread
	pthread_t tid;
	if (pthread_create(&tid, NULL, controlManager, NULL) == -1) {
		syslog(LOG_ERR,
		       "could not create the controlManager thread! Exiting...");
		clean_and_exit(EXIT_FAILURE);
	}
	// wait for the controManager thread    
	if (pthread_join(tid, NULL) != 0) {
		syslog(LOG_ERR,
		       "doit:could not join the networkManager! Exiting...");
		clean_and_exit(EXIT_FAILURE);
	}
}

/*!
Creates other threads and waits to recieve SIGHUP and than reconfigures the SisIYA daemon.
*/
void *controlManager(void *)
{
/*
	- setDefaults and conf file name
	- (re)write the the pid file (pid can be changed in the conf file)
	- (re)create networkManager (port number can be changed in the conf file)
	- (re)create cacheManager thread (the sleep time can be changed in the conf file)
	- (re)create dbWriter threads (the number of dbWriters can be changed in the conf file)
	- block all signals
	- unblock SIGHUP
	- wait for SIGHUP
*/
	int i;
	int signum;
	sigset_t set;
	while (1) {
		// set defaults and conf file name
		setDefaults();
		if (!confFile.setFileName(confFileName)) {
			syslog(LOG_ERR,
			       "controlManager: could open file %s",
			       confFileName);
			clean_and_exit(EXIT_FAILURE);
		}
		if (loglevel > 1)
			syslog(LOG_INFO,
			       "controlManager: set configuration parameters.");

		// get the loglevel. For now it is primitive made. Change it later
		loglevel = confFile.getInt("LOGLEVEL");

		// write the server pid to the pid file
		ofstream pidFile;
		pidFile.open(confFile.getString("PID_FILE").c_str(),
			     ios::out);
		if (pidFile.bad()) {
			syslog(LOG_ERR,
			       "controlManager: can't open the PID file : %s ! Exiting...",
			       confFile.getString("PID_FILE").c_str());
			clean_and_exit(EXIT_FAILURE);
		}
		pidFile << serverPID;
		pidFile.close();
		if (loglevel > 1)
			syslog(LOG_INFO,
			       "controlManager: wrote server PID=%d to the PID file.",
			       serverPID);

		// block all signals
		if (blockAllSignals() == false) {
			syslog(LOG_ERR,
			       "controlManager: could not block all signals. Exiting...");
			clean_and_exit(EXIT_FAILURE);
		}
		if (loglevel > 1)
			syslog(LOG_INFO,
			       "controlManager: blocked all signals.");

		// cancel the networkManager thread
		/*
		   if(nDBWriters != 0) {
		   if(pthread_cancel(networkManagerID) != 0) {
		   syslog(LOG_ERR,"controlManager:could not cancel the networkManager! Exiting...");
		   clean_and_exit(EXIT_FAILURE);
		   }
		   if(loglevel > 1)
		   syslog(LOG_INFO,"controlManager: canceled the networkManager thread.");

		   if(pthread_join(networkManagerID,NULL) != 0) {
		   syslog(LOG_ERR,"controlManager:could not join the networkManager! Exiting...");
		   clean_and_exit(EXIT_FAILURE);
		   }
		   if(loglevel > 1)
		   syslog(LOG_INFO,"controlManager: joined the networkManager thread.");
		   }
		 */
		// wait for the thread to finish
		if (nDBWriters != 0) {
			if (pthread_join(networkManagerID, NULL) != 0) {
				syslog(LOG_ERR,
				       "controlManager:could not join the networkManager! Exiting...");
				clean_and_exit(EXIT_FAILURE);
			}
			if (loglevel > 1)
				syslog(LOG_INFO,
				       "controlManager: joined the networkManager thread.");
		}
		// cancel the cacheManager thread
		if (nDBWriters != 0) {
/*
			if(pthread_cancel(cacheManagerID) != 0) {
				syslog(LOG_ERR,"controlManager: could not cancel the cacheManager! Exiting...");
				clean_and_exit(EXIT_FAILURE);
			}
			if(loglevel > 1)
				syslog(LOG_INFO,"controlManager: canceled the cacheManager thread.");
*/
			if (pthread_join(cacheManagerID, NULL) != 0) {
				syslog(LOG_ERR,
				       "controlManager:could not join the cacheManager! Exiting...");
				clean_and_exit(EXIT_FAILURE);
			}
			if (loglevel > 1)
				syslog(LOG_INFO,
				       "controlManager: joined the cacheManager thread.");

		}
		// cancel dbWriter threads
		if (nDBWriters != 0) {
/*
			for(i=0;i<nDBWriters;i++) {
				if(pthread_cancel(dbWriterIDs[i]) != 0) {
					syslog(LOG_ERR,"controlManager: could not cancel the %d th dbWriter thread! Exiting...",i);
					clean_and_exit(EXIT_FAILURE);
				}
				else {
					if(loglevel > 1)
						syslog(LOG_INFO,"controlManager: canceld the %d th dbWriter thread.",i);
				}
			}
*/
			// broadcast to wake up any dbWriter threads
			for (i = 0; i < nDBWriters; i++) {
				if (condBroadcast(mqueueCond) == false)
					return NULL;
			}
			for (i = 0; i < nDBWriters; i++) {
				if (pthread_join(dbWriterIDs[i], NULL) !=
				    0) {
					syslog(LOG_ERR,
					       "controlManager:could not join the %d th dbWriter thread! Exiting...",
					       i);
					clean_and_exit(EXIT_FAILURE);
				} else {
					if (loglevel > 1)
						syslog(LOG_INFO,
						       "controlManager: joined the %d th dbWriter thread.",
						       i);
				}
			}

			//      delete[] dbWriterIDs;
			//dbWriterIDs=NULL;
			if (loglevel > 1)
				syslog(LOG_INFO,
				       "controlManager: canceled %d dbWriter threads.",
				       nDBWriters);
		}

		setDone(false);
		// create the networkManager thread
		if (pthread_create
		    (&networkManagerID, NULL, networkManager,
		     NULL) == -1) {
			syslog(LOG_ERR,
			       "controlManager: could not create the networkManager thread! Exiting...");
			clean_and_exit(EXIT_FAILURE);
		}
		if (loglevel > 1)
			syslog(LOG_INFO,
			       "controlManager: created the networkManager thread.");


		// create the cacheManager thread
		if (pthread_create
		    (&cacheManagerID, NULL, cacheManager, NULL) == -1) {
			syslog(LOG_ERR,
			       "controlManager: could not create the cacheManager thread! Exiting...");
			clean_and_exit(EXIT_FAILURE);
		}
		if (loglevel > 1)
			syslog(LOG_INFO,
			       "controlManager: created the cacheManager thread.");

		// create dbWriter threads
		nDBWriters = confFile.getInt("DBWriterThreads");
		if (nDBWriters < 1) {
			// there is no way at the moment to work without db writer threads
			syslog(LOG_ERR,
			       "controlManager: DBWriterThreads=%d < 1! There is no way at the moment to work without dbWriter threads!",
			       nDBWriters);
			clean_and_exit(errno);
		}
		//dbWriterIDs=new *pthread_t[];
		//dbWriterIDs=new pthread_t[nDBWriters];
		for (i = 0; i < nDBWriters; i++) {
			//if(pthread_create(dbWriterIDs[i],NULL,dbWriter,NULL) == -1) {
			if (pthread_create
			    (&dbWriterIDs[i], NULL, dbWriter,
			     NULL) == -1) {
				syslog(LOG_ERR,
				       "controlManager: could not create the %d th dbWriter thread! Exiting...",
				       i);
				clean_and_exit(EXIT_FAILURE);
			} else {
				if (loglevel > 1)
					syslog(LOG_INFO,
					       "controlManager: created the %d th dbWriter thread.",
					       i);
			}
		}
		if (loglevel > 1)
			syslog(LOG_INFO,
			       "controlManager: created all %d dbWriter threads.",
			       nDBWriters);


		if (sigemptyset(&set) == -1) {
			syslog(LOG_ERR,
			       "controlManager: could not empty signal set!");
			clean_and_exit(EXIT_FAILURE);
		}
		if (sigaddset(&set, SIGHUP) == -1) {
			syslog(LOG_ERR,
			       "controlManager: could not add SIGHUP to the signal set!");
			clean_and_exit(EXIT_FAILURE);
		}
		sigwait(&set, &signum);
		if (loglevel > 1)
			syslog(LOG_INFO,
			       "controlManager: caught SIGHUP signal. Reconfiguring the SisIYA daemon ...");
		setDone(true);
	}
}

/*!
Assigns done a value.
*/
void setDone(bool value)
{

	if (lockMutex(doneMutex) == false) {
		syslog(LOG_ERR,
		       "setDone: could not lock the mutex doneMutex!");
		return;
	}
	done = value;
	if (unlockMutex(doneMutex) == false) {
		syslog(LOG_ERR,
		       "isDone: could not unlock the mutex doneMutex!");
		return;
	}
}

/*!
Checks the value of the done variable.
*/
bool isDone(void)
{
	bool x;

	if (lockMutex(doneMutex) == false) {
		syslog(LOG_ERR,
		       "isDone: could not lock the mutex doneMutex!");
		return true;	// this will cause the thread to exit
	}
	x = done;
	if (unlockMutex(doneMutex) == false) {
		syslog(LOG_ERR,
		       "isDone: could not unlock the mutex doneMutex!");
		return true;	// this will cause the thread to exit
	}
	return x;
}

/*!
Thread which listens to the socket and accpets client connections.
*/
void *networkManager(void *arg)
{
	int *connfd;
	socklen_t addrlen;

	if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
		syslog(LOG_ERR,
		       "networkManager: can't open stream socket (socket(AF_INET,SOCK_STREAM,0))");
		exit(1);
	}

	if (loglevel > 1)
		syslog(LOG_INFO,
		       "networkManager: opened a stream socket.");

	//bzero((char *)&serv_addr,sizeof(serv_addr));
	bzero(static_cast < sockaddr_in * >(&serv_addr),
	      sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	if (confFile.getString("IP") == "any"
	    || confFile.getString("IP") == "0.0.0.0")
		// I cannot supress the old-style-cast here because INADDR_ANY is defined with old style cast
		serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
	else if (confFile.getString("IP") == "127.0.0.1"
		 || confFile.getString("IP") == "localhost")
		serv_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	else {
		if (inet_aton
		    (confFile.getString("IP").c_str(),
		     &(serv_addr.sin_addr)) == 0) {
			syslog(LOG_ERR,
			       "networkManager: Can't convert numbers-and-dots (%s) notation into  binary  data",
			       confFile.getString("IP").c_str());
			exit(1);
		}
	}
	if (loglevel > 2)
		syslog(LOG_INFO,
		       "networkManager: inet_ntoa(serv_addr.sin_addr)=%s",
		       inet_ntoa(serv_addr.sin_addr));

	serv_addr.sin_port = htons(confFile.getInt("PORT"));

	// set SO_REUSEADDR option 
	int on = 1;
	if (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on))
	    < 0) {
		close(listenfd);
		syslog(LOG_ERR,
		       "networkManager: Cannot set SO_REUSEADDR socket option! Exiting...");
		exit(1);
	} else {
		if (loglevel > 2)
			syslog(LOG_INFO,
			       "networkManager: Set SO_REUSEADDR socket option");
	}

	if (bind
	    (listenfd, (struct sockaddr *) &serv_addr,
	     sizeof(serv_addr)) < 0) {
//      if(bind(listenfd,static_cast<struct sockaddr *>(&serv_addr),sizeof(serv_addr)) < 0) {
		close(listenfd);
		syslog(LOG_ERR,
		       "networkManager: Cannot bind local address (%s:%d). Errno=%d",
		       confFile.getString("IP").c_str(),
		       confFile.getInt("PORT"), errno);
		exit(1);
	}

	if (loglevel > 1)
		syslog(LOG_INFO,
		       "networkManager: Bind local address (%s:%d)",
		       confFile.getString("IP").c_str(),
		       confFile.getInt("PORT"));

	if (listen(listenfd, LISTENQ) == -1) {
		syslog(LOG_ERR,
		       "networkManager: Cannot listen address (%s:%d)",
		       confFile.getString("IP").c_str(),
		       confFile.getInt("PORT"));
		exit(1);
	}

	if (loglevel > 1)
		syslog(LOG_INFO, "networkManager: Start to listen");

	syslog(LOG_INFO,
	       "networkManager: Server (version=%s) started and accepting connection on interface=%s and port=%d. PID is %d",
	       VERSION, confFile.getString("IP").c_str(),
	       confFile.getInt("PORT"), serverPID);

	// data for the poll function
	struct pollfd plisten[1];
	plisten[0].fd = listenfd;
	plisten[0].events = POLLRDNORM;
	int nready;

	pthread_t tid;
	// the main loop
	for (;;) {
		nready = poll(plisten, 1, 5000);
		if (nready == -1) {
			syslog(LOG_ERR,
			       "networkManager: error calling poll! Error code=%d message=%s",
			       errno, strerror(errno));
			clean_and_exit(errno);
		}
		if (nready == 0) {
			if (loglevel > 1)
				syslog(LOG_INFO,
				       "networkManager: poll timed out.");
			// test if we should exit
			if (isDone()) {
				syslog(LOG_INFO,
				       "networkManager: done is set. Exiting...");
				close(listenfd);
				return NULL;
			}
			continue;
		}
		if (!(plisten[0].revents & POLLRDNORM)) {
			syslog(LOG_INFO,
			       "networkManager: not a new connection!?");
			continue;
		}
		addrlen = static_cast < socklen_t > (sizeof(cli_addr));
		connfd = (int *) malloc(sizeof(int));
		if (connfd == NULL) {
			syslog(LOG_ERR,
			       "networkManager: could not allocate memory for connfd (int)! Error code=%d message=%s",
			       errno, strerror(errno));
			clean_and_exit(errno);
		}
		*connfd =
		    accept(listenfd, (struct sockaddr *) &cli_addr,
			   &addrlen);

		if ((*connfd) == -1) {
			syslog(LOG_ERR,
			       "networkManager: error calling accept! Error code=%d message=%s",
			       errno, strerror(errno));
			clean_and_exit(errno);
		}
		if (loglevel > 1)
			syslog(LOG_INFO,
			       "networkManager: client(%s:%d) connected.",
			       inet_ntoa(cli_addr.sin_addr),
			       cli_addr.sin_port);
		// create a thread to process the request, the thread frees memory allocated for connfd
		pthread_create(&tid, NULL, &t_server, (void *) connfd);
	}
}

/*!
Connects to the database and returns the connection object or NULL on failure.
*/
Connection *getConnection(void)
{
	Connection *conn;

	string edbc =
	    string("edbc:") + lowerCase(confFile.getString("DB_TYPE")) +
	    string("://") + confFile.getString("DB_SERVER") + string("/") +
	    confFile.getString("DB_NAME");
	if (confFile.getInt("DB_PORT") != 0)
		edbc += string(":") + confFile.getString("DB_PORT");
	if (dm == NULL) {
		syslog(LOG_ERR,
		       "getConnection: Driver manager is not available!");
		return NULL;
	}
	try {
		conn =
		    dm->getConnection(edbc, confFile.getString("DB_USER"),
				      confFile.getString("DB_PASSWORD"));
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getConnection: Failed to connect to DB %s@%s",
		       confFile.getString("DB_USER").c_str(),
		       edbc.c_str());
		//exit(1);
		return NULL;
	}
	if (conn == NULL) {
		syslog(LOG_ERR,
		       "getConnection: Could not connect to connect DB %s@%s",
		       confFile.getString("DB_USER").c_str(),
		       edbc.c_str());
		//clean_and_exit(1);
		return NULL;
	} else if (loglevel > 1)
		syslog(LOG_INFO,
		       "getConnection: Connected to connect DB %s@%s",
		       confFile.getString("DB_USER").c_str(),
		       edbc.c_str());

	conn->setAutoCommit(true);
	if (loglevel > 1)
		syslog(LOG_INFO, "getConnection: Set auto-commit to true");
	return conn;
}


bool extract_fields(char *msg, int *serviceID, int *statusID, long *expire,
		    string & hostName, string & str,
		    string & sendTimestamp)
{
	char sp[2];

//      syslog(LOG_INFO,"extract_fields: line=[%s]",msg);
	// the first char in the message is the field seperator 
	sp[0] = msg[0];
	sp[1] = '\0';

	list < string > ls;
	stringtok(ls, msg, sp);
	ostringstream osstr;
	list < string >::const_iterator i;
	int j;
	for (j = 0, i = ls.begin(); i != ls.end(); ++i, j++);
	if (j == 6) {
		j = 0;
		for (j = 0, i = ls.begin(); i != ls.end(); ++i, j++) {
			if (j > 4)
				break;
			osstr << (*i) << " ";
		}
		osstr << ends;
		istringstream isstr(osstr.str());
		isstr >> (*serviceID) >> (*statusID) >> hostName >>
		    sendTimestamp >> (*expire);
		if (loglevel > 2)
			syslog(LOG_INFO,
			       "child server: extract_fields: hostName=[%s] serviceID=%d statusID=%d sendTimestamp=[%s] expire=%ld",
			       hostName.c_str(), *serviceID, *statusID,
			       sendTimestamp.c_str(), *expire);
		// check the sendTimestamp value
		if (sendTimestamp.size() != 14) {
			syslog(LOG_ERR,
			       "child server: extract_fields: sendTimestamp=[%s] has length of %d != 14!",
			       sendTimestamp.c_str(),
			       sendTimestamp.size());
			return false;
		}
		// all chars must be at lest digits (0-9)
		for (int k = 0; k < (int) sendTimestamp.size(); k++) {
			if (isdigit(sendTimestamp[k]) == 0) {
				syslog(LOG_ERR,
				       "child server: extract_fields: sendTimestamp=[%s] the %d th char is=%c which is not a digit!",
				       sendTimestamp.c_str(), k + 1,
				       sendTimestamp[k]);
				return false;
			}
		}
		// now check the date time itself,
		//int year=fromString<int>(string(sendTimestamp.substr(0,4)));
		int month =
		    fromString < int >(string(sendTimestamp.substr(4, 2)));
		int day =
		    fromString < int >(string(sendTimestamp.substr(6, 2)));
		int hour =
		    fromString < int >(string(sendTimestamp.substr(8, 2)));
		int minutes =
		    fromString <
		    int >(string(sendTimestamp.substr(10, 2)));
		int seconds =
		    fromString <
		    int >(string(sendTimestamp.substr(12, 2)));
		//syslog(LOG_ERR,"child server: extract_fields: sendTimestamp=[%s] year=%d month=%d day=%d hour=%d minutes=%d seconds=%d",sendTimestamp.c_str(),year,month,day,hour,minutes,seconds);
		/*
		   if(year != now_year) {
		   syslog(LOG_ERR,"child server(%d): extract_fields: sendTimestamp=[%s] invalid year=%d!",childPID,sendTimestamp.c_str(),year);
		   return false;
		   }
		 */
		if (month > 12) {
			syslog(LOG_ERR,
			       "child server: extract_fields: sendTimestamp=[%s] invalid month=%d (> 12)!",
			       sendTimestamp.c_str(), month);
			return false;
		}
		if (day > 31) {
			syslog(LOG_ERR,
			       "child server: extract_fields: sendTimestamp=[%s] invalid day=%d (> 31)!",
			       sendTimestamp.c_str(), day);
			return false;
		}
		if (hour > 23) {
			syslog(LOG_ERR,
			       "child server: extract_fields: sendTimestamp=[%s] invalid hour=%d (> 23)!",
			       sendTimestamp.c_str(), hour);
			return false;
		}
		if (minutes > 59) {
			syslog(LOG_ERR,
			       "child server: extract_fields: sendTimestamp=[%s] invalid minutes=%d (> 59)!",
			       sendTimestamp.c_str(), minutes);
			return false;
		}
		if (seconds > 59) {
			syslog(LOG_ERR,
			       "child server: extract_fields: sendTimestamp=[%s] invalid seconds=%d (> 59)!",
			       sendTimestamp.c_str(), seconds);
			return false;
		}
	} else
		return false;
	if (i != ls.end())
		str = trim((*i));
	return true;
}

/*!
Excecutes the given sql which must return one row with a integer column.
\return	INT_MIN on error or the result of the query as a integer value.
*/
int getIntValue(Connection * conn, string & sql)
{
	int retvalue = INT_MIN;

	Statement *stmt = NULL;
	try {
		stmt = conn->createStatement();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getIntValue: Error creating a Statement object! Caught SQLException : %s",
		       e.getMessage().c_str());
		return retvalue;
	}
	ResultSet *rs = NULL;
	try {
		rs = stmt->executeQuery(sql);
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getIntValue: Caught SQLException! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return retvalue;
	}
	if (rs == NULL) {
		syslog(LOG_ERR,
		       "getIntValue: Query [%s] executiuon failed!",
		       sql.c_str());
		delete stmt;
		return retvalue;
	} else if (loglevel > 2)
		syslog(LOG_INFO, "getIntValue: Query [%s] execution OK",
		       sql.c_str());
	ResultSetMetaData *rsmd;
	try {
		rsmd = rs->getResultSetMetaData();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getIntValue: Caught SQLException! Could not create ResultSetMetadata object! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return retvalue;

	}
	if (rsmd == NULL) {
		syslog(LOG_ERR,
		       "getIntValue: Could not create ResultSetMetadata object!");
		delete rs;
		delete stmt;
		return retvalue;
	}
	if (rsmd->getRowCount() != 1) {
		if (loglevel > 2)
			syslog(LOG_INFO,
			       "getIntValue: No results for the query [%s]!",
			       sql.c_str());
		delete rsmd;
		delete rs;
		delete stmt;
		return retvalue;
	}
	rs->first();
	try {
		retvalue = rs->getInt(0);
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getIntValue: Caught SQLException! Could not get retvalue Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rsmd;
		delete rs;
		delete stmt;
		return retvalue;

	}
	delete rsmd;
	delete rs;
	delete stmt;
	return (retvalue);
}


/*!
Checks in the status table whether the status ID is valid or not.
*/
bool checkStatusID(Connection * conn, int statusID)
{
	string sql =
	    "select id from status where id=" + toString(statusID);

	Statement *stmt = NULL;
	try {
		stmt = conn->createStatement();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "checkStatusID: Error creating a Statement object! Caught SQLException : %s",
		       e.getMessage().c_str());
		return false;
	}
	ResultSet *rs = NULL;
	try {
		rs = stmt->executeQuery(sql);
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "checkStatusID: Caught SQLException! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return false;
	}
	if (rs == NULL) {
		syslog(LOG_ERR,
		       "checkStatusID: Query [%s] executiuon failed!",
		       sql.c_str());
		delete stmt;
		return false;
	} else if (loglevel > 2)
		syslog(LOG_INFO, "checkStatusID: Query [%s] execution OK",
		       sql.c_str());
	ResultSetMetaData *rsmd;
	try {
		rsmd = rs->getResultSetMetaData();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "checkStatusID: Caught SQLException! Could not create ResultSetMetadata object! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return false;
	}
	if (rsmd == NULL) {
		syslog(LOG_ERR,
		       "checkStatusID: Could not create ResultSetMetadata object!");
		delete rs;
		delete stmt;
		return false;
	}
	if (rsmd->getRowCount() != 1) {
		if (loglevel > 2)
			syslog(LOG_INFO,
			       "checkStatusID: No such statusid=%d!",
			       statusID);
		delete rsmd;
		delete rs;
		delete stmt;
		return false;
	}
	if (loglevel > 2)
		syslog(LOG_INFO, "checkStatusID: status id=%d is valid",
		       statusID);
	delete rsmd;
	delete rs;
	delete stmt;
	return true;
}

/*!
Checks in the status table if the whether the status ID is valid or not.
*/
bool checkStatusIDFromCache(int statusID)
{
	return true;
	/*
	   bool retcode=checkStatusID(statusID);
	   if(retcode == false) {
	   syslog(LOG_ERR,"checkStatusIDFromCache: no such statusID=%d",statusID);
	   }
	   return retcode;
	 */
}

/*!
Checks in the status table if the whether the status ID is valid or not.
*/
bool checkServiceID(Connection * conn, int serviceID)
{
	string sql =
	    "select id from services where id=" + toString(serviceID);

	Statement *stmt = NULL;
	try {
		stmt = conn->createStatement();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "checkServiceID: Error creating a Statement object! Caught SQLException : %s",
		       e.getMessage().c_str());
		return false;
	}
	ResultSet *rs = NULL;
	try {
		rs = stmt->executeQuery(sql);
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "checkServiceID: Caught SQLException! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return false;
	}
	if (rs == NULL) {
		syslog(LOG_ERR,
		       "checkServiceID: Query [%s] executiuon failed!",
		       sql.c_str());
		delete stmt;
		return false;
	} else if (loglevel > 2)
		syslog(LOG_INFO, "checkServiceID: Query [%s] execution OK",
		       sql.c_str());
	ResultSetMetaData *rsmd;
	try {
		rsmd = rs->getResultSetMetaData();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "checkServiceID: Caught SQLException! Could not create ResultSetMetadata object! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return false;
	}
	if (rsmd == NULL) {
		syslog(LOG_ERR,
		       "checkServiceID: Could not create ResultSetMetadata object!");
		delete rs;
		delete stmt;
		return false;
	}
	if (rsmd->getRowCount() != 1) {
		if (loglevel > 2)
			syslog(LOG_INFO,
			       "checkServiceID: No such service id=%d!",
			       serviceID);
		delete rsmd;
		delete rs;
		delete stmt;
		return false;
	}
	if (loglevel > 2)
		syslog(LOG_INFO, "checkServiceID: service id=%d is valid",
		       serviceID);
	delete rsmd;
	delete rs;
	delete stmt;
	return true;
}

/*!
Checks in the status table if the whether the status ID is valid or not.
*/
bool checkServiceIDFromCache(int serviceID)
{
	return true;
/*
	if(retcode  == false) {
		syslog(LOG_ERR,"checkServiceIDFromCache: no such serviceID=%d",serviceID);
	}
	return retcode;
*/
}

/*!
Retrieves the system id from cache.
\return	0 : no such system; -x	: the system with ID=x is not enabled
*/
int getSystemIDFromCache(string hostName)
{


	// use the old function for now
	int systemID = -1;
	Connection *conn = getConnection();
	if (conn == NULL) {
		syslog(LOG_INFO,
		       "getSystemIDFromCache: could not get connection object!");
		return systemID;
	}

	systemID = getSystemID(conn, hostName);
	if (loglevel > 2)
		syslog(LOG_INFO, "getSystemIDFromCache: systemID=%d",
		       systemID);

	if (systemID <= 0) {
		if (systemID == 0)
			syslog(LOG_ERR,
			       "getSystemIDFromCache: no such system=%s",
			       hostName.c_str());
		else if (systemID < 2)
			syslog(LOG_ERR,
			       "getSystemIDFromCache: the system %s with systemID=%d is not enabled. Disable client check for this or enabled the system.",
			       hostName.c_str(), -1 * systemID);
	}
	delete conn;
	return systemID;
}



/*!
Retrieves the system id from systems table.
\return	0 : no such system; -x	: the system with ID=x is not enabled
*/
int getSystemID(Connection * conn, string hostName)
{
	int systemID = 0;	// set to no such system


	string sql = "select id,active from systems where ";
	if (hostName.find('.') == string::npos)
		sql.append("hostname='");
	else
		sql.append("fullhostname='");
	sql.append(hostName + string("'"));

	Statement *stmt = NULL;
	try {
		stmt = conn->createStatement();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getSystemID: Error creating a Statement object! Caught SQLException : %s",
		       e.getMessage().c_str());
		return systemID;
	}
	ResultSet *rs = NULL;
	try {
		rs = stmt->executeQuery(sql);
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getSystemID: Caught SQLException! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return systemID;
	}
	if (rs == NULL) {
		syslog(LOG_ERR,
		       "getSystemID: Query [%s] executiuon failed!",
		       sql.c_str());
		delete stmt;
		return systemID;
	} else if (loglevel > 2)
		syslog(LOG_INFO, "getSystemID: Query [%s] execution OK",
		       sql.c_str());
	ResultSetMetaData *rsmd;
	try {
		rsmd = rs->getResultSetMetaData();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getSystemID: Caught SQLException! Could not create ResultSetMetadata object! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return systemID;

	}
	if (rsmd == NULL) {
		syslog(LOG_ERR,
		       "getSystemID: Could not create ResultSetMetadata object!");
		delete rs;
		delete stmt;
		return systemID;
	}
	if (rsmd->getRowCount() != 1) {
		if (loglevel > 2)
			syslog(LOG_INFO,
			       "getSystemID: No such system with name=[%s]!",
			       hostName.c_str());
		delete rsmd;
		delete rs;
		delete stmt;
		return systemID;	// no such system
	}
	rs->first();
	try {
		systemID = rs->getInt(0);
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getSystemID: Caught SQLException! Could not get systemID Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rsmd;
		delete rs;
		delete stmt;
		return systemID;

	}

	try {
		if (rs->getString(1) == "f")
			systemID = -1 * systemID;	// the system is not enabled
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getSystemID: Caught SQLException! Could not get systems active flag! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rsmd;
		delete rs;
		delete stmt;
		return systemID;

	}
	if (loglevel > 2)
		syslog(LOG_INFO, "getSystemID: systemID=%d", systemID);
	delete rsmd;
	delete rs;
	delete stmt;
	return (systemID);
}


void getTimestamp(string & str)
{
	time_t tt;
	struct tm *t;

	time(&tt);
	t = localtime(&tt);

	char buf[15];
	// change this to use ostringstream
	sprintf(buf, "%d%.2d%.2d%.2d%.2d%.2d", 1900 + t->tm_year,
		1 + t->tm_mon, t->tm_mday, t->tm_hour, t->tm_min,
		t->tm_sec);
	str = buf;
};

/*!
Retrieves update and change times for the speciefied system.
\return true on success or false on error.
*/
bool getSystemUpdateChangeTimes(Connection * conn, int systemID,
				string & updateTime, string & changeTime)
{
	string sql =
	    string
	    ("select updatetime from systemservicestatus where systemid=")
	    + toString(systemID) + string(" order by updatetime desc");

	Statement *stmt = NULL;
	try {
		stmt = conn->createStatement();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getSystemUpdateChangeTimes: Error creating a Statement object! Caught SQLException : %s",
		       e.getMessage().c_str());
		return false;
	}
	ResultSet *rs = NULL;
	try {
		rs = stmt->executeQuery(sql);
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getSystemUpdateChangeTimes: Caught SQLException! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return false;
	}
	if (rs == NULL) {
		syslog(LOG_ERR,
		       "getSystemUpdateChangeTimes: Query [%s] executiuon failed!",
		       sql.c_str());
		delete stmt;
		return false;
	} else if (loglevel > 2)
		syslog(LOG_INFO,
		       "getSystemUpdateChangeTimes: Query [%s] execution OK",
		       sql.c_str());
	ResultSetMetaData *rsmd;
	try {
		rsmd = rs->getResultSetMetaData();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getSystemUpdateChangeTimes: Caught SQLException! Could not create ResultSetMetadata object! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return false;
	}
	if (rsmd == NULL) {
		syslog(LOG_ERR,
		       "getSystemUpdateChangeTimes: Could not create ResultSetMetadata object!");
		delete rs;
		delete stmt;
		return false;
	}
	if (rsmd->getRowCount() == 0) {
		if (loglevel > 2)
			syslog(LOG_INFO,
			       "getSystemUpdateChangeTimes: No records for systemID=%d in the systemservicestatus table!",
			       systemID);
		delete rsmd;
		delete rs;
		delete stmt;
		return false;
	}
	rs->first();
	try {
		updateTime = rs->getString(0);
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getSystemUpdateChangeTimes: Caught SQLException! Could not get systemID Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rsmd;
		delete rs;
		delete stmt;
		return false;

	}
	/*
	   I am going to use the same statement object, so I must not delete rs and rsmd s 
	   delete rsmd;
	   delete rs;
	 */

	sql =
	    string
	    ("select changetime from systemservicestatus where systemid=")
	    + toString(systemID) + string(" order by changetime desc");
	try {
		rs = stmt->executeQuery(sql);
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getSystemUpdateChangeTimes: Caught SQLException! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return false;
	}
	if (rs == NULL) {
		syslog(LOG_ERR,
		       "getSystemUpdateChangeTimes: Query [%s] executiuon failed!",
		       sql.c_str());
		delete stmt;
		return false;
	} else if (loglevel > 2)
		syslog(LOG_INFO,
		       "getSystemUpdateChangeTimes: Query [%s] execution OK",
		       sql.c_str());
	try {
		rsmd = rs->getResultSetMetaData();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getSystemUpdateChangeTimes: Caught SQLException! Could not create ResultSetMetadata object! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return false;
	}
	if (rsmd == NULL) {
		syslog(LOG_ERR,
		       "getSystemUpdateChangeTimes: Could not create ResultSetMetadata object!");
		delete rs;
		delete stmt;
		return false;
	}
	if (rsmd->getRowCount() == 0) {
		delete rsmd;
		delete rs;
		delete stmt;
		return false;
	}
	rs->first();
	try {
		changeTime = rs->getString(0);
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getSystemUpdateChangeTimes: Caught SQLException! Could not get systemID Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rsmd;
		delete rs;
		delete stmt;
		return false;

	}
	delete rsmd;
	delete rs;
	delete stmt;

	return true;
}

/*!
Retrieves the system status information for the specified system.
\return true on success or false on error.
*/
bool getErrorWarningMessage(Connection * conn, int systemID,
			    string & error_warning)
{
	string sql =
	    string
	    ("select b.str,c.str from systemservicestatus a,services b,status c where a.serviceid=b.id and a.statusid=c.id and systemid=")
	    + toString(systemID) +
	    string(" and c.id > 1 order by statusid desc");

	Statement *stmt = NULL;
	try {
		stmt = conn->createStatement();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getErrorWarningMessage: Error creating a Statement object! Caught SQLException : %s",
		       e.getMessage().c_str());
		return false;
	}
	ResultSet *rs = NULL;
	try {
		rs = stmt->executeQuery(sql);
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getErrorWarningMessage: Caught SQLException! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return false;
	}
	if (rs == NULL) {
		syslog(LOG_ERR,
		       "getErrorWarningMessage: Query [%s] executiuon failed!",
		       sql.c_str());
		delete stmt;
		return false;
	} else if (loglevel > 2)
		syslog(LOG_INFO,
		       "getErrorWarningMessage: Query [%s] execution OK",
		       sql.c_str());
	ResultSetMetaData *rsmd;
	try {
		rsmd = rs->getResultSetMetaData();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "getErrorWarningMessage: Caught SQLException! Could not create ResultSetMetadata object! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		return false;
	}
	if (rsmd == NULL) {
		syslog(LOG_ERR,
		       "getErrorWarningMessage: Could not create ResultSetMetadata object!");
		delete rs;
		delete stmt;
		return false;
	}
	if (rsmd->getRowCount() == 0) {
		//if(loglevel > 2)
		//      syslog(LOG_INFO,"getSystemUpdateChangeTimes: No records for systemID=%d in the systemservicestatus table!",systemID);
		delete rsmd;
		delete rs;
		delete stmt;
		return false;
	}
	error_warning = "";
	while (rs->next()) {
		try {
			error_warning.append(rs->getString(0));
			error_warning.append(string("("));
			error_warning.append(rs->getString(1));
			error_warning.append(string(") "));

		}
		catch(SQLException & e) {
			syslog(LOG_ERR,
			       "getErrorWarningMessage: Caught SQLException! Could not get systemID Reason: %s SQL State: %s Vendor error code: %d",
			       e.getMessage().c_str(),
			       e.getSQLState().c_str(), e.getErrorCode());
			delete rsmd;
			delete rs;
			delete stmt;
			return false;
		}
	}
	error_warning = trim(error_warning);
	delete rsmd;
	delete rs;
	delete stmt;
	return true;
}

bool updateAllSystemStatus(void)
{
	Connection *conn = getConnection();
	if (conn == NULL) {
		syslog(LOG_ERR,
		       "updateAllSystemStatus: could not get Connection object");
		return false;
	}

	string sql = string("select id from systems where active='t'");

	Statement *stmt = NULL;
	try {
		stmt = conn->createStatement();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "updateAllSystemStatus: Error creating a Statement object! Caught SQLException : %s",
		       e.getMessage().c_str());
		delete conn;
		return false;
	}
	ResultSet *rs = NULL;
	try {
		rs = stmt->executeQuery(sql);
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "updateAllSystemStatus: Caught SQLException! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		delete conn;
		return false;
	}
	if (rs == NULL) {
		syslog(LOG_ERR,
		       "updateAllSystemStatus: Query [%s] executiuon failed!",
		       sql.c_str());
		delete stmt;
		return false;
	} else if (loglevel > 3)
		syslog(LOG_INFO,
		       "updateAllSystemStatus: Query [%s] execution OK",
		       sql.c_str());
	ResultSetMetaData *rsmd;
	try {
		rsmd = rs->getResultSetMetaData();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "updateAllSystemStatus: Caught SQLException! Could not create ResultSetMetadata object! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete rs;
		delete stmt;
		delete conn;
		return false;
	}
	if (rsmd == NULL) {
		syslog(LOG_ERR,
		       "updateAllSystemStatus: Could not create ResultSetMetadata object!");
		delete rs;
		delete stmt;
		delete conn;
		return false;
	}
	if (rsmd->getRowCount() == 0) {
		delete rsmd;
		delete rs;
		delete stmt;
		delete conn;
		return false;
	}
	while (rs->next()) {
		try {
			if (updateSystemStatus(conn, rs->getInt(0)) ==
			    false) {
				syslog(LOG_ERR,
				       "updateAllSystemStatus: Could not create ResultSetMetadata object!");
				delete rsmd;
				delete rs;
				delete stmt;
				delete conn;
				return false;
			}

		}
		catch(SQLException & e) {
			syslog(LOG_ERR,
			       "getErrorWarningMessage: Caught SQLException! Could not get systemID Reason: %s SQL State: %s Vendor error code: %d",
			       e.getMessage().c_str(),
			       e.getSQLState().c_str(), e.getErrorCode());
			delete rsmd;
			delete rs;
			delete stmt;
			delete conn;
			return false;
		}
	}
	delete rsmd;
	delete rs;
	delete stmt;
	delete conn;

	return true;
}

bool updateSystemStatus(Connection * conn, int systemID)
{
	int systemStatusID;
	string updateTime, changeTime;

	if (getSystemUpdateChangeTimes
	    (conn, systemID, updateTime, changeTime) == false) {
		syslog(LOG_INFO,
		       "updateSystemStatus: Could not get change and update times from the systemservicestatus table. Generating...");
		getTimestamp(changeTime);
		getTimestamp(updateTime);
	}
	// get the system status
	string sql =
	    string("select statusid from systemstatus where systemid=") +
	    toString(systemID);

	systemStatusID = getIntValue(conn, sql);
	string error_warning;

	// get the max status from systemservicestatus
	sql =
	    string
	    ("select max(statusid) from systemservicestatus where systemid=")
	    + toString(systemID);
	int maxStatusID = getIntValue(conn, sql);

	if (loglevel > 2)
		syslog(LOG_INFO,
		       "updateSystemStatus: Got system max(statusid)=%d for systemID=%d",
		       maxStatusID, systemID);

	if (systemStatusID != INT_MIN) {
		// it is going to be an update
		if (maxStatusID < 2)	// The system is OK
			sql =
			    string("update systemstatus set statusid=") +
			    toString(MESSAGE_OK) +
			    string(",updatetime='") + updateTime +
			    string("',str='System is OK' where systemid=")
			    + toString(systemID);
		else {		// System has warnings and/or errors
			if (getErrorWarningMessage
			    (conn, systemID, error_warning) == false) {
				syslog(LOG_ERR,
				       "updateSystemStatus: Could not get error and/or warning messages for the system=%d. maxStatusID=%d",
				       systemID, maxStatusID);
				error_warning =
				    "There was no status info!";
			}
			if (maxStatusID != systemStatusID)
				sql =
				    string
				    ("update systemstatus set statusid=") +
				    toString(maxStatusID) +
				    string(",changetime='") + changeTime +
				    string("',updatetime='") + updateTime +
				    string("',str='") + error_warning +
				    string("' where systemid=") +
				    toString(systemID);
			else
				sql =
				    string
				    ("update systemstatus set updatetime='")
				    + updateTime + string("',str='") +
				    error_warning +
				    string("' where systemid=") +
				    toString(systemID);
		}
	} else {
		// check this logic !!! There is a probem when a client sends a message for a not valid service ID ?!
		// new record
		systemStatusID = maxStatusID;
		if (systemStatusID < 2)
			sql =
			    string("insert into systemstatus values(") +
			    toString(systemID) + string(",") +
			    toString(systemStatusID) + string(",'") +
			    updateTime + string("','") + changeTime +
			    string("','System is OK')");
		else {
			if (getErrorWarningMessage
			    (conn, systemID, error_warning) == false) {
				syslog(LOG_ERR,
				       "updateSystemStatus: Could not get error and/or warning messages for the system=%d",
				       systemID);
				error_warning =
				    "There was no status info!";
			}
			sql =
			    string("insert into systemstatus values(") +
			    toString(systemID) + string(",") +
			    toString(systemStatusID) + string(",'") +
			    updateTime + string("','") + changeTime +
			    string("','") + error_warning + string("')");
		}
	}

	Statement *stmt;
	try {
		stmt = conn->createStatement();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "updateSystemStatus: Error creating a Statement object! Caught SQLException : %s",
		       e.getMessage().c_str());
		return false;
	}
	try {
		if (stmt->executeUpdate(sql) != 1) {
//                      syslog(LOG_ERR,"updateSystemStatus: Query [%s] executiuon failed! Update or insert must produce exactly 1 row?!",sql.c_str());
			delete stmt;
//                      return false;
			return true;
		} else if (loglevel > 2)
			syslog(LOG_INFO,
			       "updateSystemStatus: Query [%s] execution OK",
			       sql.c_str());
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "updateSystemStatus: Caught SQLException! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete stmt;
		return false;
	}
	delete stmt;
	return true;
}

bool insertMessage(Connection * conn, SisIYAMessage & sm)
{
	return (insertMessage
		(conn, sm.getSystemID(), sm.getServiceID(),
		 sm.getStatusID(), sm.getExpire(), sm.getSendTimestamp(),
		 sm.getMessage()));
}

bool insertMessage(Connection * conn, long unsigned int systemID,
		   long unsigned int serviceID,
		   short unsigned int statusID, long unsigned int expire,
		   string sendTimestamp, string message)
{
	string recieveTimestamp;
	getTimestamp(recieveTimestamp);

	// for systemhistorystatus table
	string sql =
	    string("insert into systemhistorystatus values('") +
	    sendTimestamp + string("',") + toString(systemID) +
	    string(",") + toString(serviceID) + string(",") +
	    toString(statusID) + string(",'") + recieveTimestamp +
	    string("','") + message + string("')");

	Statement *stmt;
	try {
		stmt = conn->createStatement();
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "insertMessage: Error creating a Statement object! Caught SQLException : %s",
		       e.getMessage().c_str());
		return false;
	}
	try {
		if (stmt->executeUpdate(sql) != 1) {
			syslog(LOG_ERR,
			       "insertMessage: Query [%s] executiuon failed! Insert must produce exactly 1 row?!",
			       sql.c_str());
			delete stmt;
			return false;
		} else if (loglevel > 2)
			syslog(LOG_INFO,
			       "insertMessage: Query [%s] execution OK",
			       sql.c_str());
	}
	catch(SQLException & e) {
		syslog(LOG_ERR,
		       "insertMessage: Caught SQLException! Reason: %s SQL State: %s Vendor error code: %d",
		       e.getMessage().c_str(), e.getSQLState().c_str(),
		       e.getErrorCode());
		delete stmt;
		return false;
	}

	// for systemservice table
	sql =
	    string
	    ("select statusid from systemservicestatus where systemid=") +
	    toString(systemID) + string(" and serviceid=") +
	    toString(serviceID);
	int sID = getIntValue(conn, sql);
	if (sID != INT_MIN) {
		// update 
		if (sID != statusID)
			sql =
			    string
			    ("update systemservicestatus set statusid=") +
			    toString(statusID) + string(",changetime='") +
			    recieveTimestamp + string("',updatetime='") +
			    recieveTimestamp + string("',expires=") +
			    toString(expire) + string(",str='") + message +
			    string("' where systemid=") +
			    toString(systemID) +
			    string(" and serviceid=") +
			    toString(serviceID);
		else
			sql =
			    string
			    ("update systemservicestatus set statusid=") +
			    toString(statusID) + string(",updatetime='") +
			    recieveTimestamp + string("',expires=") +
			    toString(expire) + string(",str='") + message +
			    string("' where systemid=") +
			    toString(systemID) +
			    string(" and serviceid=") +
			    toString(serviceID);
		try {
			if (stmt->executeUpdate(sql) != 1) {
				syslog(LOG_ERR,
				       "insertMessage: Query [%s] executiuon failed! Update must produce exactly 1 row?!",
				       sql.c_str());
				delete stmt;
				return false;
			} else if (loglevel > 2)
				syslog(LOG_INFO,
				       "insertMessage: Query [%s] execution OK",
				       sql.c_str());
		}
		catch(SQLException & e) {
			syslog(LOG_ERR,
			       "insertMessage: Caught SQLException! Reason: %s SQL State: %s Vendor error code: %d",
			       e.getMessage().c_str(),
			       e.getSQLState().c_str(), e.getErrorCode());
			delete stmt;
			return false;
		}
	} else {
		// new record
		sql =
		    string("insert into systemservicestatus values(") +
		    toString(systemID) + string(",") +
		    toString(serviceID) + string(",") +
		    toString(statusID) + string(",'") + recieveTimestamp +
		    string("','") + recieveTimestamp + string("',") +
		    toString(expire) + string(",'") + message +
		    string("')");
		try {
			if (stmt->executeUpdate(sql) != 1) {
				syslog(LOG_ERR,
				       "insertMessage: Query [%s] executiuon failed! Insert must produce exactly 1 row?!",
				       sql.c_str());
				delete stmt;
				return false;
			} else if (loglevel > 2)
				syslog(LOG_INFO,
				       "insertMessage: Query [%s] execution OK",
				       sql.c_str());
		}
		catch(SQLException & e) {
			syslog(LOG_ERR,
			       "insertMessage: Caught SQLException! Reason: %s SQL State: %s Vendor error code: %d",
			       e.getMessage().c_str(),
			       e.getSQLState().c_str(), e.getErrorCode());
			delete stmt;
			return false;
		}
	}
	delete stmt;
	return true;
}

//! Thread for managing the SisIYA cache, which includes, systems, services and status.
void *cacheManager(void *arg)
{
/*
	pthread_t tid=pthread_self();
	if(detachThread(&tid) == false) {
		syslog(LOG_ERR,"cacheManager: could not detach thread!");
		return NULL;
	}
	if(loglevel > 2)
		syslog(LOG_INFO,"cacheManager: thread detached itself.");
*/
	if (loglevel > 2)
		syslog(LOG_INFO, "cacheManager: thread started.");
	Connection *conn = getConnection();
	if (conn == NULL) {
		syslog(LOG_ERR,
		       "cacheManager: could not connect to the database!");
		//return false;
		clean_and_exit(1);
	}
	while (1) {
		if (lockMutex(cacheMutex) == false) {
			syslog(LOG_ERR,
			       "cacheManager: could not lock the mutex cacheMutex!");
			return false;
		}
		if (loglevel > 3)
			syslog(LOG_INFO,
			       "cacheManager: get lock on the cachMutex");
		// update systems  : searched with system name or full system name
		// update services : searched with service id 
		// update status   : searched with status id

		if (updateCache(conn) == false) {
			syslog(LOG_ERR,
			       "cacheManager: could not update the cache!");
		} else {
			if (loglevel > 3)
				syslog(LOG_INFO,
				       "cacheManager: updated the cache.");
		}
		if (updateDB(conn) == false) {
			syslog(LOG_ERR,
			       "cacheManager: could not update DB from cache!");
		} else {
			if (loglevel > 3)
				syslog(LOG_INFO,
				       "cacheManager: updated DB from cache.");
		}
		if (unlockMutex(cacheMutex) == false) {
			syslog(LOG_ERR,
			       "cacheManager: could not unlock the mutex cacheMutex!");
			return false;
		}
		if (loglevel > 3)
			syslog(LOG_INFO,
			       "cacheManager: unlocked the mutex cacheMutex after updating the cache");
		if (isDone()) {
			syslog(LOG_INFO,
			       "cacheManager: done is set. Exiting...");
			break;
		}
		// sleep or cond wait
		//sleep(180); // 3 minutes
		sleep(60);	// 1 minutes
		if (isDone()) {
			syslog(LOG_INFO,
			       "cacheManager: done is set. Exiting...");
			break;
		}
	}
	// close the connection 
	delete conn;
	if (loglevel > 3)
		syslog(LOG_INFO, "cacheManager: disconnected from DB.");
	return NULL;
}

//! Creates the signalManager thread with higher priority.
bool createSignalManager(void)
{
	int retcode;
	pthread_attr_t threadAttr;
	struct sched_param param;
	int policy;

	retcode = pthread_attr_init(&threadAttr);
	if (retcode != 0) {
		syslog(LOG_ERR,
		       "createSignalManager: could not initialize default thread attribute! Error code=%d",
		       retcode);
		return false;
	}
	retcode = pthread_attr_getschedparam(&threadAttr, &param);
	if (retcode != 0) {
		syslog(LOG_ERR,
		       "createSignalManager: could not get schedule parameters! Error code=%d",
		       retcode);
		return false;
	}
	retcode = pthread_attr_getschedpolicy(&threadAttr, &policy);
	if (retcode != 0) {
		syslog(LOG_ERR,
		       "createSignalManager: could not get schedule policy! Error code=%d",
		       retcode);
		return false;
	}
	if (param.sched_priority < sched_get_priority_max(policy)) {
		param.sched_priority++;
		retcode = pthread_attr_setschedparam(&threadAttr, &param);
		if (retcode != 0) {
			syslog(LOG_ERR,
			       "createSignalManager: could not set schedule parameter! Error code=%d",
			       retcode);
			return false;
		}
	}
	pthread_t tid;
	retcode = pthread_create(&tid, &threadAttr, signalManager, NULL);
	if (retcode != 0) {
		syslog(LOG_ERR,
		       "createSignalManager: could not get create signalManager thread! Error code=%d",
		       retcode);
		return false;
	}

	return true;
}

//! Thread for managing signals.
void *signalManager(void *arg)
{
	sigset_t set;
	int retcode;
	int signum;

	pthread_t tid = pthread_self();
	if (detachThread(&tid) == false) {
		syslog(LOG_ERR, "signalManager: could not detach thread!");
		return NULL;
	}
	if (loglevel > 2)
		syslog(LOG_INFO, "signalManager: thread detached itself.");

	if (loglevel > 2)
		syslog(LOG_INFO, "signalManager: thread started.");

	retcode = sigemptyset(&set);
	if (retcode == -1) {
		syslog(LOG_ERR,
		       "signalManager: could not empty signal set!");
		clean_and_exit(EXIT_FAILURE);
	}
	retcode = sigaddset(&set, SIGTERM);
	if (retcode == -1) {
		syslog(LOG_ERR,
		       "signalManager: could not add SIGTERM to the signal set!");
		clean_and_exit(EXIT_FAILURE);
	}
	retcode = sigaddset(&set, SIGQUIT);
	if (retcode == -1) {
		syslog(LOG_ERR,
		       "signalManager: could not add SIGQUIT to the signal set!");
		clean_and_exit(EXIT_FAILURE);
	}
	retcode = sigaddset(&set, SIGUSR1);
	if (retcode == -1) {
		syslog(LOG_ERR,
		       "signalManager: could not add SIGUSR1 to the signal set!");
		clean_and_exit(EXIT_FAILURE);
	}
/*
	Signals are already blocked by doit

	retcode=sigprocmask(SIG_BLOCK,&set,NULL);
	if(retcode == -1) {
		syslog(LOG_ERR,"signalManager: could not set process signal mask!");
		clean_and_exit(EXIT_FAILURE);
	}
*/
	while (1) {
		retcode = sigwait(&set, &signum);
		switch (signum) {
		case SIGQUIT:
			syslog(LOG_INFO,
			       "signalManager: caught SIGQUIT signal. Exiting...");
			clean_and_exit(EXIT_SUCCESS);
			break;
		case SIGTERM:
			syslog(LOG_INFO,
			       "signalManager: caught SIGTERM signal. Exiting ...");
			clean_and_exit(EXIT_SUCCESS);
			break;
		case SIGUSR1:
			syslog(LOG_INFO,
			       "signalManager: caught SIGUSR1 signal. Printing SisIYA configuration to syslog ...");
			sisiya_showconf();
			break;
		default:
			syslog(LOG_INFO,
			       "signalManager: caught unexpected signal=%d.",
			       signum);
			break;
		}
	}
	return NULL;
}

/*!
Update the cache from DB.
*/
bool updateCache(Connection * conn)
{
	return true;
}

/*!
Update DB from cache.
*/
bool updateDB(Connection * conn)
{
	return updateAllSystemStatus();
}

bool detachThread(pthread_t * tid)
{
	int retcode = pthread_detach(*tid);
	switch (retcode) {
	case 0:		// OK
		break;
	case ESRCH:
		syslog(LOG_ERR,
		       "no thread could be found to detach! Etrror code=%d message=%s",
		       retcode, strerror(retcode));
		return false;
		break;
	case EINVAL:
		syslog(LOG_ERR,
		       "thread is already in detached state! Etrror code=%d message=%s",
		       retcode, strerror(retcode));
		return false;
		break;
	default:
		syslog(LOG_ERR,
		       "could not detach thread! Etrror code=%d message=%s",
		       retcode, strerror(retcode));
		return false;
		break;
	}
	return true;
}

//! Thread for reading SisIYA messages from the queue and inserting them into the database.
void *dbWriter(void *arg)
{
/*
	pthread_t tid=pthread_self();
	if(detachThread(&tid) == false) {
		syslog(LOG_ERR,"dbWriter: could not detach thread!");
		return NULL;
	}

	if(loglevel > 2)
		syslog(LOG_INFO,"dbWriter: thread detached itself.");
*/
	if (loglevel > 2)
		syslog(LOG_INFO, "dbWriter: thread started.");
	Connection *conn = getConnection();
	if (conn == NULL) {
		syslog(LOG_ERR,
		       "dbWriter: could not connect to the database!");
		//return false;
		clean_and_exit(1);
	}
	while (1) {
		// see if there are any messages in the queue
		if (lockMutex(mqueueMutex) == false) {
			syslog(LOG_ERR,
			       "dbWriter: could not lock the mutex mqueueMutex!");
			return false;
		}
		if (loglevel > 3)
			syslog(LOG_INFO,
			       "dbWriter: got lock on the mqueueMutex");

		if (mqueue.size() < 1) {
			if (loglevel > 3)
				syslog(LOG_INFO,
				       "dbWriter: waiting for condition on mqueueCond and mqueueMutex.");
			// go to sleep
			if (condWait(mqueueCond, mqueueMutex) == false) {
				syslog(LOG_ERR,
				       "dbWriter: could wait for condition on mqueueCond and mutex mqueueMutex!");
				return false;
			} else {
				if (loglevel > 3)
					syslog(LOG_INFO,
					       "dbWriter: wake up after waiting for condition on mqueueCond and mqueueMutex.");
				if (isDone()) {
					syslog(LOG_INFO,
					       "dbWriter: done is set. Exiting...");
					break;
				}
			}
		}
		if (mqueue.size() < 1) {
			if (unlockMutex(mqueueMutex) == false) {
				syslog(LOG_ERR,
				       "dbWriter: could not unlock the mutex mqueueMutex!");
				return false;
			} else {
				if (loglevel > 3)
					syslog(LOG_INFO,
					       "dbWriter: unlocked the mqueueMutex. Nothing to do.");
			}
			continue;
		}
		// get the first message
		SisIYAMessage sm = *mqueue.begin();
		// remove the first message 
		mqueue.pop_front();

		if (unlockMutex(mqueueMutex) == false) {
			syslog(LOG_ERR,
			       "dbWriter: could not unlock the mutex mqueueMutex!");
			return false;
		}
		if (loglevel > 3)
			syslog(LOG_INFO,
			       "dbWriter: unlocked the mutex mqueueMutex after adding to the queue");
		// insert the message into the db
//syslog(LOG_INFO,"dbWriter: systemid=%ld serviceid=%ld statusid=%d sendTimestamp=[%s] expires=[%ld] msg=[%s]",sm.getSystemID(),sm.getServiceID(),sm.getStatusID(),sm.getSendTimestamp().c_str(),sm.getExpire(),sm.getMessage().c_str());

		if (insertMessage(conn, sm) == false) {
			syslog(LOG_ERR,
			       "dbWriter: could not insert the message %s!",
			       sm.getMessage().c_str());
		}

	}
	// close the connection 
	delete conn;
	if (loglevel > 3)
		syslog(LOG_INFO, "dbWriter: disconnected from DB.");
	return NULL;
}

void *t_server(void *arg)
{
	pthread_t tid = pthread_self();
	if (detachThread(&tid) == false) {
		syslog(LOG_ERR, "t_server: could not detach thread!");
		return NULL;
	}
	if (loglevel > 2)
		syslog(LOG_INFO, "thread detached itself.");

	if (loglevel > 2)
		syslog(LOG_INFO, "thread started.");


	int connfd = *((int *) arg);
	free(arg);

	if (processClient(connfd) == false)
		return NULL;
	// broadcast to wake up any dbWriter threads
	if (condBroadcast(mqueueCond) == false)
		return NULL;
/*
	if(loglevel > 2)
		syslog(LOG_INFO,"thread with ID=%d getting lock on the ndbconnMutex mutex to decrement ndbconn=%d",(int)tid,ndbconn);    

	if(lockMutex(ndbconnMutex) == false) {
		 syslog(LOG_ERR,"child server(%d) : could not lock the ndbconnMutexi mutex!",childPID);
	}
	else {
		if(loglevel > 2)
			syslog(LOG_INFO,"thread with ID=%d got lock on the ndbconnMutex mutex to decrement ndbconn=%d",(int)tid,ndbconn);    
		ndbconn--;
		if(loglevel > 2)
			syslog(LOG_INFO,"thread with ID=%d decremented ndbconn=%d",(int)tid,ndbconn);    
		if(loglevel > 2)
			syslog(LOG_INFO,"thread with ID=%d about to signal ndbconnCond conditional variable",(int)tid);    
		// awake one of the waiting threads, if there are any
		if(condSignal(ndbconnCond) == false)
			syslog(LOG_ERR,"child server(%d) : could not signal the conditional variable ndbconnCond!",childPID);
		if(loglevel > 2) 
			syslog(LOG_INFO,"thread with ID=%d signaled ndbconnCond conditional variablei. Unlocking the ndbconnMutex mutex",(int)tid);    
		if(unlockMutex(ndbconnMutex) == false)
			syslog(LOG_ERR,"child server(%d) : could not unlock the mutex ndbconnMutex!",childPID);
		if(loglevel > 2) 
			syslog(LOG_INFO,"thread with ID=%d unlocked the ndbconnMutex mutex",(int)tid);    
	}

	if(retflag == false) {
		return NULL;
	}
*/
	return NULL;
}

/*!
Read from the connected socket, create a SisIYA messages and add them to the queue.
*/
bool processClient(int connfd)
{
	string hostName, old_hostName, str, sendTimestamp;
	int systemID = -1;
	int serviceID, statusID;
	long int expire;
	char line[MAX_STR];
	int n;

	if (loglevel > 2)
		syslog(LOG_INFO,
		       "processClient: starting to read from socket %d",
		       connfd);
	while (1) {
		if ((n = readline(connfd, line, MAX_STR)) < 0) {
			syslog(LOG_ERR,
			       "processClient: socket read error");
			return false;
		}
		if (n == 0)
			break;

		if (loglevel > 2)
			syslog(LOG_INFO,
			       "processClient: recieved data : [%s]\n",
			       line);
		if (extract_fields
		    (line, &serviceID, &statusID, &expire, hostName, str,
		     sendTimestamp) == false) {
			syslog(LOG_ERR,
			       "processClient: msg=[%s] has wrong format!",
			       line);
			continue;
		}
		if (loglevel > 2)
			syslog(LOG_INFO,
			       "processClient: serviceid=%d statusid=%d hostname=[%s] sendTimestamp=[%s] expires=[%ld] msg=[%s]",
			       serviceID, statusID, hostName.c_str(),
			       sendTimestamp.c_str(), expire, str.c_str());

		if (old_hostName != hostName) {
			systemID = getSystemIDFromCache(hostName);
		}

		if (systemID <= 0) {
			continue;	// the system is not enabled or no such system
		}
		if (checkStatusIDFromCache(statusID) == false) {
			str =
			    str + string(" Status id=") +
			    toString(statusID) +
			    string(" is not defined in SisIYA!");
			statusID = MESSAGE_ERROR;
		}
		if (checkServiceIDFromCache(serviceID) == false) {
			systemID = -1;	// set to -1 untill I have a better way of error control
			continue;
		}

		old_hostName = hostName;

		string recieveTimestamp;
		getTimestamp(recieveTimestamp);
		SisIYAMessage sm((unsigned long int) systemID,
				 (unsigned long int) serviceID,
				 (unsigned short int) statusID,
				 (unsigned long int) expire, sendTimestamp,
				 recieveTimestamp, str);

		if (loglevel > 2)
			syslog(LOG_INFO,
			       "processClient: systemid=%ld serviceid=%ld statusid=%d hostname=[%s] sendTimestamp=[%s] expires=[%ld] msg=[%s]",
			       sm.getSystemID(), sm.getServiceID(),
			       sm.getStatusID(), hostName.c_str(),
			       sm.getSendTimestamp().c_str(),
			       sm.getExpire(), sm.getMessage().c_str());

		// lock
		if (lockMutex(mqueueMutex) == false) {
			syslog(LOG_ERR,
			       "processClient: could not lock the mutex mqueueMutex!");
			return false;
		}
		if (loglevel > 3)
			syslog(LOG_INFO,
			       "processClient: get lock on the mqueueMutex");

		// add the message to the end of the queue
		mqueue.push_back(sm);

		if (unlockMutex(mqueueMutex) == false) {
			syslog(LOG_ERR,
			       "processClient: could not unlock the mutex mqueueMutex!");
			return false;
		}
		if (loglevel > 3)
			syslog(LOG_INFO,
			       "processClient: unlocked the mutex mqueueMutex after adding to the queue");
	}
	if (loglevel > 2)
		syslog(LOG_ERR, "processClient: queue size=%d",
		       mqueue.size());
	return true;
}

//! Locks the specified mutex. Ruterns true on success, false on error.
bool lockMutex(pthread_mutex_t & mutex)
{
	int retcode = pthread_mutex_lock(&mutex);
	switch (retcode) {
	case 0:
		return true;
		//break;
	case EINVAL:
		syslog(LOG_ERR,
		       "lockMutex: child server : the mutex is not properly inituialized!");
		break;
	case EDEADLK:
		syslog(LOG_ERR,
		       "lockMutex: child server : the mutex is already lock by the calling thread!");
		break;
	default:
		syslog(LOG_ERR,
		       "lockMutex: child server : got unknown error code=%d while trying to lock the mutex!",
		       retcode);
		break;
	}
	return false;
}

//! Unlocks the specified mutex. Ruterns true on success, false on error.
bool unlockMutex(pthread_mutex_t & mutex)
{
	int retcode = pthread_mutex_unlock(&mutex);
	switch (retcode) {
	case 0:
		return true;
		//break;
	case EINVAL:
		syslog(LOG_ERR,
		       "unlockMutex: child server : the mutex is not properly inituialized");
		break;
	case EPERM:
		syslog(LOG_ERR,
		       "unlockMutex: child server : the calling thread does not own this mutex!");
		break;
	default:
		syslog(LOG_ERR,
		       "unlockMutex: child server : got unknown error code=%d while trying to unlock the mutex!",
		       retcode);
		break;
	}
	return false;
}

//! Waits on the cond conditional variable using the mutex. Returns true on success, false on error.
bool condWait(pthread_cond_t & cond, pthread_mutex_t & mutex)
{
	if (pthread_cond_wait(&cond, &mutex) == 0)
		return true;
	// According to the man page this function never returns a error code.
	syslog(LOG_ERR,
	       "condWait: child server : got unknown error while waiting on the conditional variable!");
	return false;

}

//! Awakens one of the waiting threads for a conditional variable. Returns true on success, false on error.
bool condSignal(pthread_cond_t & cond)
{
	if (pthread_cond_signal(&cond) == 0)
		return true;
	// According to the man page this function never returns a error code.
	syslog(LOG_ERR,
	       "condSignal: child server : got unknown error while signalling for the conditional variable!");
	return false;
}

//! Awakens all waiting threads for a conditional variable. Returns true on success, false on error.
bool condBroadcast(pthread_cond_t & cond)
{
	if (pthread_cond_broadcast(&cond) == 0)
		return true;
	// According to the man page this function never returns a error code.
	syslog(LOG_ERR,
	       "condBroadcast: child server : got unknown error while broadcasting the conditional variable!");
	return false;

}

/*
bool server(int sfd)
{

	clock_t tcstart,tcend;
	struct tms tmstart,tmend;
	double clockticks,cticks;
	
	if(loglevel > 2) {
		if((int)(clockticks=(double)sysconf(_SC_CLK_TCK)) == -1) {
			syslog(LOG_ERR,"child server(%d) : could not get _SC_CLK_TCK!",childPID);
			return false;
		}
		syslog(LOG_INFO,"child server(%d) : the number of ticks per second is clockticks=%f",childPID,clockticks);
		if((int)clockticks == 0) {
			syslog(LOG_ERR,"child server(%d) : the number of ticks per second is invalid!",childPID);
			return false;
		}
		if((int)(tcstart=times(&tmstart)) == -1) {
			syslog(LOG_ERR,"child server(%d) : failed to get start time!",childPID);
			return false;
		}
	}	
	if(lockMutex(ndbconnMutex) == false) {
		syslog(LOG_ERR,"child server(%d) : could not lock the mutex ndbconnMutex!",childPID);
		return false;
	}
	if(loglevel > 3)
		syslog(LOG_INFO,"child server(%d) : get lock on the ndbconnMutex mutex",childPID);
	if(ndbconn >= confFile.getInt("DB_MAX_CONCURRENT_CONNECTIONS")) {
		while(ndbconn < confFile.getInt("DB_MAX_CONCURRENT_CONNTIONS")) {
			if(condWait(ndbconnCond,ndbconnMutex) == false) {
				syslog(LOG_ERR,"child server(%d) : failed wait for the condition variable ndbconnCond!",childPID);
				return false;
			}
			if(loglevel > 3)
				syslog(LOG_INFO,"child server(%d) : get lock on the ndbconnMutex mutex after waiting for a condition to occure",childPID);
		}
	}
	ndbconn++;
	if(unlockMutex(ndbconnMutex) == false) {
		syslog(LOG_ERR,"child server(%d) : could not unlock the mutex ndbconnMutex!",childPID);
		ndbconn--;
		return false;
	}
	if(loglevel > 3)
		syslog(LOG_INFO,"child server(%d) : unlocked the mutex ndbconnMutex after incrementing ndbconn=%d",childPID,ndbconn);

	string hostName,old_hostName,str,sendTimestamp;
	int systemID=-1,old_systemID=-1;
	int serviceID,statusID;
	long int expire;
	bool error=false;
	char line[MAX_STR];
	int n;
	if(esignal(SIGALRM,sig_alarm) == SIG_ERR) {
		syslog(LOG_ERR,"child server(%d) : could not set signal handler for SIGALRM!",childPID);
		return false;
	}

	if(loglevel > 2) 
		syslog(LOG_INFO,"child server(%d) : starting to read from socket %d",childPID,sfd);
	while(1) {
		if((n=readline(sfd,line,MAX_STR)) < 0) {
			syslog(LOG_ERR,"socket read error");
			return false; 
		}
		// cancel the alarm
		if(loglevel > 2)
			syslog(LOG_INFO,"child server(%d) : canceled alarm (remaining seconds=%d) for ReadTimeout of %d seconds.",childPID,alarm(0),confFile.getInt("ReadTimeout"));
		else
			alarm(0);
		if(n == 0)
			break;

		if(loglevel > 2) 
			syslog(LOG_INFO,"child server(%d) recieved data : [%s]\n",childPID,line);
		if(extract_fields(line,&serviceID,&statusID,&expire,hostName,str,sendTimestamp) == false) {
			syslog(LOG_ERR,"child server(%d) msg=[%s] has wrong format!",childPID,line);
			continue;
		}
		if(loglevel > 2)
			syslog(LOG_INFO,"child server(%d) serviceid=%d statusid=%d hostname=[%s] sendTimestamp=[%s] expires=[%ld] msg=[%s]",childPID,serviceID,statusID,hostName.c_str(),sendTimestamp.c_str(),expire,str.c_str());

		if(old_hostName != hostName) {
			systemID=getSystemID(hostName);
			if(loglevel > 2)
				syslog(LOG_INFO,"child server(%d) : systemID=%d",childPID,systemID);
		}

		if(systemID <= 0) { 
			if(systemID == 0)
				syslog(LOG_ERR,"child server(%d) : no such system=%s",childPID,hostName.c_str());
			else if(systemID < 2)
				syslog(LOG_ERR,"child server(%d) : the system %s with systemID=%d is not enabled. Disable client check for this or enabled the system.",childPID,hostName.c_str(),-1*systemID);
			continue; // the system is not enabled or no such system
		}
		if(checkStatusID(statusID) == false) {
			syslog(LOG_ERR,"child server(%d) : no such statusID=%d",childPID,statusID);
			str=str+string(" Status id=")+toString(statusID)+string(" is not defined in SisIYA!");
			statusID=MESSAGE_ERROR;
		}
		if(checkServiceID(conn,serviceID) == false) {
			syslog(LOG_ERR,"child server(%d) : no such serviceID=%d",childPID,serviceID);
			systemID=-1; // set to -1 untill I have a better way of error control
			continue;
		}

		if(old_systemID != -1 && old_systemID != systemID) {
			if(loglevel > 2)
				syslog(LOG_INFO,"child server(%d) : systemID is changed (old_systemID=%d,systemID=%d) => update systemstatus",childPID,old_systemID,systemID);
			if(updateSystemStatus(old_systemID) == false) {
				syslog(LOG_ERR,"child server(%d) : could not update systemstatus for systemID=%d",childPID,old_systemID);
				error=true;
				break;
			}
			else {
				if(loglevel > 2)
					syslog(LOG_INFO,"child server(%d) : (1)updated systemstatus for systemID=%d",childPID,old_systemID);
			}
		}
		old_systemID=systemID;
		old_hostName=hostName;

		if(insertMessage(conn,systemID,serviceID,statusID,expire,sendTimestamp,str) == false) {
			error=true;
			break;
		}
	}
	if(error) {
		return false;
	}
	if(old_systemID == -1 && systemID == -1) {
		syslog(LOG_ERR,"child server(%d) : old_systemID=systemID=%d",childPID,systemID);
		return false;
	}
	if(old_systemID != -1 && updateSystemStatus(systemID) == false) {
		syslog(LOG_ERR,"child server(%d) : failed to update systemstatus table for systemID=%d",childPID,systemID);
		return false;
	}
	else {
		if(loglevel > 2)
			syslog(LOG_INFO,"child server(%d) : (2)updated systemstatus for systemID=%d old_systemid=%d",childPID,systemID,old_systemID);
	}

	if(loglevel > 2) {
		if((tcend=times(&tmend)) == -1) {
			syslog(LOG_ERR,"child server(%d) : failed to get end time!",childPID);
			return false;
		}
		cticks=tmend.tms_utime+tmend.tms_stime-tmstart.tms_utime-tmstart.tms_stime;
		syslog(LOG_INFO,"child server(%d) : total CPU execution time = %f",childPID,cticks/clockticks);
		if((tcend <= tcstart) || tcend < 0 || tcstart < 0) {
			syslog(LOG_ERR,"child server(%d) : tick time wrapped, couldn't calculate fraction!",childPID);
			return false;
		}
		syslog(LOG_INFO,"child server(%d) : fraction CPU time used is %f",childPID,cticks/(tcend-tcstart));
	}
	return true;
}

*/

/*!
Main function.
*/
int main(int argc, char *argv[])
{
	if (argc != 2) {
		cerr << "Usage : " << argv[0] << " sisiyad.conf" << endl;
		return 1;
	}
	openlog("sisiyad", LOG_PID, LOG_USER);	/* Open the syslog. Log progname and pid */

	pname = argv[0];
	confFileName = argv[1];
	doit();
	return 0;
}
