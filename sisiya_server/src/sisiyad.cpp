/*
    Copyright (C) 2005  Erdal Mutlu

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

/*
#ifdef HAVE_CONFIG_H
	#include"config.h"
#endif
*/

#include<iostream>
#include<fstream>
//#include<pthread.h>
#include<syslog.h>
#include<list>
#include<string>
#include<sstream>

// this is a C++ program
#ifndef __cplusplus
	#define __cplusplus
#endif

#include"common.hpp"
/*
 Declare all C functions with
	BEGIN_C_DECLS
	C function list
	END_C_DECLS
*/

#include<sys/times.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<sys/stat.h>
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<signal.h>
#include<setjmp.h>

#include<error.h>
#include<string.h>

#include"misc.h"
#include"esignal.hpp"

#include"ConfFile.hpp"
#include"Semaphore.hpp"
#include"UpperLowerCase.hpp"
#include"trim.hpp"
#include"stringtok.hpp"
#include"stringConvert.hpp"

#include"Connection.hpp"
#include"DriverManager.hpp"
#include"SQLException.hpp"
#include"SisIYAServer.hpp"
/*
BEGIN_C_DECLS
END_C_DECLS
*/
// backlog value for listen()
#define LISTENQ 5

using namespace std;

//! The name of the configuration file.
char * confFileName;
//! Coonection object
Connection *conn=NULL;
//! DriverManager object
DriverManager *dm;
//! EDBC string
string edbc;

//! The name of the program.
char *pname;
//! Configuration file object.
ConfFile confFile;
//! The process ID of the server process
pid_t serverPID;
//! loglevel variable, change the code to use confFile.getInt("LOGLEVEL")
int loglevel;
//!
int sockfd;
//! Semaphore used for locking
Semaphore *sem;

//! The server and client socketaddr structures
struct sockaddr_in cli_addr,serv_addr;

//! Environment variable for sigsetjump() used for SIGHUP
static jmp_buf env_reconfigure;

// defined in include/config.h generated by autoconf/automake #define RETSIGTYPE void

/*************************************************************************************/
void clean_and_exit(int code);
void clean_up(void);
int daemon_init(void);
void doit(void);
RETSIGTYPE sig_child(int signo);
RETSIGTYPE sig_quit(int signo);
RETSIGTYPE sig_hup(int signo);
RETSIGTYPE sig_term(int signo);
RETSIGTYPE sig_usr1(int signo);
void sisiya_showconf(void);

/***********************************************************************/

/*************************************************************************************/
/*!
Signal handler for SIGCHLD.
*/
RETSIGTYPE sig_child(int signo)
{
 
	int status;
//	pid_t pid=wait(&status);
	pid_t pid; 
	int saved_errno=errno; // save the errno value

	while((pid=waitpid(-1,&status,WNOHANG)) > 0) {
		if(loglevel > 1)
			syslog(LOG_INFO,"child server(%s:%d) pid=%d terminated with status=%d",inet_ntoa(cli_addr.sin_addr),cli_addr.sin_port,pid,status);

		if(WIFEXITED(status) != 0){
			if(loglevel > 1)
				syslog(LOG_INFO,"child server(%s:%d) pid=%d terminated normally.",inet_ntoa(cli_addr.sin_addr),cli_addr.sin_port,pid);
		}
		else 
			syslog(LOG_ERR,"child server(%s:%d) pid=%d terminated abnormally!",inet_ntoa(cli_addr.sin_addr),cli_addr.sin_port,pid);
	}
	errno=saved_errno; // restore the errno value
}

/*!
Signal handler for SIGQUIT.
*/
RETSIGTYPE sig_quit(int signo)
{
	if(loglevel > 1)
		syslog(LOG_INFO,"child server(%s:%d) caught SIGQUIT (%d)",inet_ntoa(cli_addr.sin_addr),cli_addr.sin_port,signo);
	clean_and_exit(EXIT_SUCCESS);
}

/*!
Signal handler for SIGHUP. This way we reconfigure our server.
*/
RETSIGTYPE sig_hup(int signo)
{
	syslog(LOG_INFO,"Server(%s:%d) caught SIGHUP (%d). Reloading configuration.",inet_ntoa(cli_addr.sin_addr),cli_addr.sin_port,signo);
	// restore the set of blocked signals if any		
	siglongjmp(env_reconfigure,1);
}


/*!
Signal handler for SIGTERM.
*/
RETSIGTYPE sig_term(int signo)
{
	if(loglevel > 1)
		syslog(LOG_INFO,"server caught SIGTERM (%d)",signo);
	clean_and_exit(EXIT_SUCCESS);
}

/*!
Signal handler for SIGUSR1. Log the configuration options via syslog.
*/
RETSIGTYPE sig_usr1(int signo)
{
	sisiya_showconf();
}

/*! 
Performs clean up and exits with the specified exit code.
*/
void clean_and_exit(int code)
{
	clean_up();
	if(code != 0)
		syslog(LOG_INFO,"exited with error code=%d",code);
	else
		syslog(LOG_INFO,"exited");

	exit(code);
}

/*! 
Performs clean up.
*/
void clean_up(void)
{
	pid_t pid;

	pid=getpid();
	// This must be done only if we are the daemon.

	if(pid == serverPID) {
		// Exiting the daemon
		close(sockfd);
		if(loglevel > 2)
			syslog(LOG_INFO,"closed sockfd %d.",sockfd);

		if(loglevel > 2)
			syslog(LOG_INFO,"removing semaphore=%d.",sem->getID());
		delete sem;
		sem=NULL;
		if(loglevel > 2)
			syslog(LOG_INFO,"semaphore is removed.");
		if(conn != NULL) {
			delete conn;
			conn=NULL;
			if(loglevel > 1)
				syslog(LOG_INFO,"Disconnected from DB %s@%s",confFile.getString("DB_USER").c_str(),edbc.c_str());
		}
		// remove the pid file	
		if(unlink(confFile.getString("PID_FILE").c_str()) != 0) {
			syslog(LOG_ERR,"can't unlink the PID file : %s !",confFile.getString("PID_FILE").c_str());
		}
		if(loglevel > 1)
			syslog(LOG_INFO,"Removed the pid file %s",confFile.getString("PID_FILE").c_str());
	
 	}
}


/*!
Print the configuration information to syslog.
*/
void sisiya_showconf(void)
{
	syslog(LOG_INFO,"StartServers : [%d]",confFile.getInt("StartServers"));
	syslog(LOG_INFO,"MaxClients : [%d]",confFile.getInt("MaxClients"));
	syslog(LOG_INFO,"MinSpareThreads : [%d]",confFile.getInt("MinSpareThreads"));
	syslog(LOG_INFO,"MaxSpareThreads : [%d]",confFile.getInt("MaxSpareThreads"));
	syslog(LOG_INFO,"ReadTimeout : [%d]",confFile.getInt("ReadTimeout"));
	syslog(LOG_INFO,"PID_FILE : [%s]",confFile.getString("PID_FILE").c_str());
	syslog(LOG_INFO,"LOGLEVEL : [%d]",confFile.getInt("LOGLEVEL"));
	syslog(LOG_INFO,"IP : [%s]",confFile.getString("IP").c_str());
	syslog(LOG_INFO,"PORT : [%d]",confFile.getInt("PORT"));
	syslog(LOG_INFO,"DB_SERVER : [%s]",confFile.getString("DB_SERVER").c_str());
	syslog(LOG_INFO,"DB_TYPE : [%s]",confFile.getString("DB_TYPE").c_str());
	syslog(LOG_INFO,"DB_NAME : [%s]",confFile.getString("DB_NAME").c_str());
	syslog(LOG_INFO,"DB_USER : [%s]",confFile.getString("DB_USER").c_str());
	syslog(LOG_INFO,"DB_PASSWORD : [*******]");
}

/*!
*/
void showConfigs(void)
{
	cout << "StartServers		: [" << confFile.getInt("StartServers") << "]" << endl;
	cout << "MaxClients		: [" << confFile.getInt("MaxClients") << "]" << endl;
	cout << "MinSpareThreads		: [" << confFile.getInt("MinSpareThreads") << "]" << endl;
	cout << "MaxSpareThreads		: [" << confFile.getInt("MaxSpareThreads") << "]" << endl;
	cout << "ReadTimeout		: [" << confFile.getInt("ReadTimeout") << "]" << endl;
	cout << "PID_FILE		: [" << confFile.getString("PID_FILE") << "]" << endl;
	cout << "LOGLEVEL		: [" << confFile.getInt("LOGLEVEL") << "]" << endl;
	cout << "IP			: [" << confFile.getString("IP") << "]" << endl;
	cout << "PORT			: [" << confFile.getInt("PORT") << "]" << endl;
	cout << "DB_SERVER		: [" << confFile.getString("DB_SERVER") << "]" << endl;
	cout << "DB_TYPE			: [" << confFile.getString("DB_TYPE") << "]" << endl;
	cout << "DB_NAME			: [" << confFile.getString("DB_NAME") << "]" << endl;
	cout << "DB_USER			: [" << confFile.getString("DB_USER") << "]" << endl;
	cout << "DB_PASSWORD		: [" << confFile.getString("DB_PASSWORD") << "]" << endl;
}

void setDefaults(void)
{
	confFile.setDefault("StartServers",5);
	confFile.setDefault("MaxClients",600);
	confFile.setDefault("MinSpareThreads",10);
	confFile.setDefault("MaxSpareThreads",30);
	confFile.setDefault("ReadTimeout",10);
	confFile.setDefault("PID_FILE","/var/run/sisiyad.pid");
	confFile.setDefault("LOGLEVEL",0);
	confFile.setDefault("SEMKEY",11);
	confFile.setDefault("IP","any");
	confFile.setDefault("PORT",8888);
	confFile.setDefault("DB_SERVER","localhost");
	//confFile.setDefault("DB_TYPE","PostgreSQL");
	confFile.setDefault("DB_TYPE","MySQL");
	confFile.setDefault("DB_NAME","sisiya");
	confFile.setDefault("DB_USER","sisiyauser");
	confFile.setDefault("DB_PASSWORD","sisiyauser1");
	if(confFile.getString("DB_TYPE") == "PostgreSQL")
		confFile.setDefault("DB_PORT",5432);
	else if(confFile.getString("DB_TYPE") == "MySQL")
		confFile.setDefault("DB_PORT",3306);
	else
		confFile.setDefault("DB_PORT",0);
}

/*!
Initialize a daemon process.
*/
int daemon_init(void)
{
	pid_t pid;

	pid=fork();
	if(pid < 0)
		return(-1);
	else if(pid != 0)
		exit(0); // the parent exits

	// the child process continues
	pid=setsid(); // become session leader
	if(pid == -1) {
		syslog(LOG_ERR,"cannot set session id");
		exit(1);
	}
 
	// change working dir to /, so that we do not occupie any mounts
	if(chdir("/") != 0) {
		syslog(LOG_ERR,"cannot change dir to /");
		exit(1);
	}
 
	umask(0); // clear our file creation mask, so that any inherited restriction do not apply
	return(0);
};

void doit(void)
{
	int newsockfd;
	socklen_t addrlen;
	//! The proccess ID of the child server
	pid_t childPID;

	/* become a daemon */
	if(daemon_init() == -1) {
		syslog(LOG_ERR,"could not fork. Exiting...");
		clean_and_exit(EXIT_FAILURE);
	}
	// here I should jump when there is SIGHUP
	if(sigsetjmp(env_reconfigure,1) != 0) {
		syslog(LOG_INFO,"Reconfiguring SisIYA daemon...");
		// clean up
		clean_up();
	}
	setDefaults();
	confFile.setFileName(confFileName);
	if(!confFile.setFileName(confFileName)) {
		syslog(LOG_ERR,"could open file %s",confFileName);
		clean_and_exit(EXIT_FAILURE);
	}
	// Set the loglevel. For now it is primitive made. Change it later
	loglevel=confFile.getInt("LOGLEVEL"); 

	// I ignore exited childs till I test it extensively. Normally there is no need to handle the exited child proccesses
	// in SisIYA daemon.
	if(esignal(SIGCHLD,SIG_IGN) == SIG_ERR) {
		syslog(LOG_ERR,"could not set SIGCHLD to SIG_IGN. Exiting...");
		clean_and_exit(EXIT_FAILURE);
	}
	/*
	esignal(SIGCHLD,sig_child) == SIG_ERR) {
		syslog(LOG_ERR,"could not set signal handler for SIGCHLD. Exiting...");
		clean_and_exit(EXIT_FAILURE);
	}
	*/
	if(esignal(SIGQUIT,sig_quit) == SIG_ERR) {
		syslog(LOG_ERR,"could not set signal handler for SIGQUIT. Exiting...");
		clean_and_exit(EXIT_FAILURE);
	}
	if(esignal(SIGTERM,sig_term) == SIG_ERR) {
		syslog(LOG_ERR,"could not set signal handler for SIGTERM. Exiting...");
		clean_and_exit(EXIT_FAILURE);
	}
	if(esignal(SIGUSR1,sig_usr1) == SIG_ERR) {
		syslog(LOG_ERR,"could not set signal handler for SIGUSR1. Exiting...");
		clean_and_exit(EXIT_FAILURE);
	}
	if(esignal(SIGHUP,sig_hup) == SIG_ERR) {
		syslog(LOG_ERR,"could not set signal handler for SIGHUP. Exiting...");
		clean_and_exit(EXIT_FAILURE);
	}

	if(loglevel > 2)
		syslog(LOG_INFO,"signal handlers are set");

	serverPID=getpid();

	ofstream pidFile;
	pidFile.open(confFile.getString("PID_FILE").c_str(),ios::out);
	if(pidFile.bad()) {
		syslog(LOG_ERR,"can't open the PID file : %s ! Exiting...",confFile.getString("PID_FILE").c_str());
		clean_and_exit(EXIT_FAILURE); 
	}
	pidFile << serverPID;
	pidFile.close();


	if((sockfd=socket(AF_INET,SOCK_STREAM,0)) < 0) {
		syslog(LOG_ERR,"can't open stream socket (socket(AF_INET,SOCK_STREAM,0))");
		exit(1);
	}
 
	if(loglevel > 1)
		syslog(LOG_INFO,"opened a stream socket.");
 
	//bzero((char *)&serv_addr,sizeof(serv_addr));
	bzero(static_cast<sockaddr_in *>(&serv_addr),sizeof(serv_addr));
	serv_addr.sin_family=AF_INET;
	if(confFile.getString("IP") == "any" || confFile.getString("IP") == "0.0.0.0")
		// I cannot supress the old-style-cast here because INADDR_ANY is define with old style cast
		serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);
	else if(confFile.getString("IP") == "127.0.0.1" || confFile.getString("IP") == "localhost")
		serv_addr.sin_addr.s_addr=htonl(INADDR_LOOPBACK);
	else {	 
		if(inet_aton(confFile.getString("IP").c_str(),&(serv_addr.sin_addr)) == 0) {
			syslog(LOG_ERR,"Can't convert numbers-and-dots (%s) notation into  binary  data",confFile.getString("IP").c_str());
			exit(1);
		} 
	} 
	if(loglevel > 2)
		syslog(LOG_INFO,"inet_ntoa(serv_addr.sin_addr)=%s",inet_ntoa(serv_addr.sin_addr));
  
	serv_addr.sin_port=htons(confFile.getInt("PORT"));

	// set SO_REUSEADDR option 
	int on=1;
	if(setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR, &on, sizeof(on)) < 0) {
		close(sockfd);
		syslog(LOG_ERR,"Cannot set SO_REUSEADDR socket option! Exiting...");
		exit(1);
	}
	else {
		if(loglevel > 2)
			syslog(LOG_INFO,"Set SO_REUSEADDR socket option");
	}
 
	if(bind(sockfd,(struct sockaddr *)&serv_addr,sizeof(serv_addr)) < 0) {
//	if(bind(sockfd,static_cast<struct sockaddr *>(&serv_addr),sizeof(serv_addr)) < 0) {
		close(sockfd);
		syslog(LOG_ERR,"Cannot bind local address (%s:%d)",confFile.getString("IP").c_str(),confFile.getInt("PORT"));
		exit(1);
	} 

	if(loglevel > 1)
		syslog(LOG_INFO,"Bind local address (%s:%d)",confFile.getString("IP").c_str(),confFile.getInt("PORT"));

	if(listen(sockfd,LISTENQ) == -1) {
		syslog(LOG_ERR,"Cannot listen address (%s:%d)",confFile.getString("IP").c_str(),confFile.getInt("PORT"));
		exit(1);
	}

	if(loglevel > 1)
		syslog(LOG_INFO,"Start to listen");

	key_t semkey;
	//semkey=(key_t)confFile.getInt("SEMKEY");
	semkey=static_cast<key_t>(confFile.getInt("SEMKEY"));
	// I should use try catch 
	//sem=new Semaphore(semkey,1);
	sem=new Semaphore(semkey);
	if(loglevel > 2)
		syslog(LOG_INFO,"created semaphore=%d.",sem->getID());

	// Connect to the database system.
	edbc=string("edbc:")+lowerCase(confFile.getString("DB_TYPE"))+string("://")+confFile.getString("DB_SERVER")+string("/")+confFile.getString("DB_NAME");
	if(confFile.getInt("DB_PORT") != 0)
		edbc+=string(":")+confFile.getString("DB_PORT");
	if(conn != NULL)
		delete conn;
	if(dm != NULL)
		delete dm;
	try {
		dm=new DriverManager;
		conn=dm->getConnection(edbc,confFile.getString("DB_USER"),confFile.getString("DB_PASSWORD"));
	}
	catch(SQLException &e) {
		syslog(LOG_ERR,"Failed to connect to DB %s@%s! Exiting...",confFile.getString("DB_USER").c_str(),edbc.c_str());
		clean_and_exit(1);
	}
	if(conn == NULL) {
			syslog(LOG_ERR,"doit: Could not connect to connect DB %s@%s",confFile.getString("DB_USER").c_str(),edbc.c_str());
			clean_and_exit(1);
	}
	else
		if(loglevel > 1)
			syslog(LOG_INFO,"Connected to connect DB %s@%s",confFile.getString("DB_USER").c_str(),edbc.c_str());
	
	conn->setAutoCommit(true);
		if(loglevel > 1)
			syslog(LOG_INFO,"Set auto-commit to true");
	
	syslog(LOG_INFO,"Server (version=%s) started and accepting connection on interface=%s and port=%d. PID is %d",VERSION,confFile.getString("IP").c_str(),confFile.getInt("PORT"),serverPID); 
	 
	for(;;) {
		addrlen=static_cast<socklen_t>(sizeof(cli_addr));
		/* restart accept if interrupted by signal
		while((newsockfd=accept(sockfd,(struct sockaddr *)&cli_addr,&addrlen)), newsockfd == -1 && errno == EINTR)
			;
		*/
		newsockfd=accept(sockfd,(struct sockaddr *)&cli_addr,&addrlen);
		//newsockfd=accept(sockfd,static_cast<struct sockaddr *>(&cli_addr),&addrlen);
		if(newsockfd == -1) {
			if(errno == EINTR)
                                continue; // interrupted by a signal
			/*
			char errmsg[MAX_STR];
			if(strerror_r(errno,errmsg,MAX_STR) == NULL) {
				syslog(LOG_ERR,"error calling accept and after strerror_r! Error for strerror_r code=%d",errno);
				clean_and_exit(errno);
			}
			syslog(LOG_ERR,"error calling accept! Error code=%d message=%s",errno,errmsg);
			syslog(LOG_ERR,"error calling accept! Error code=%d message=%s",errno,strerror_r(errno,errmsg,MAX_STR));
			*/
			syslog(LOG_ERR,"error calling accept! Error code=%d message=%s",errno,strerror(errno));
			clean_and_exit(errno);
		}
		if(loglevel > 1)
			syslog(LOG_INFO,"client(%s:%d) connected.",inet_ntoa(cli_addr.sin_addr),cli_addr.sin_port);
		if((childPID=fork()) < 0) { 
			syslog(LOG_ERR,"Cannot fork");
			exit(1);
		}
		else if(childPID == 0) {	// child process 
			childPID=getpid(); 
 
			if(setpgid(0,childPID) == -1)
				syslog(LOG_ERR,"child server[%d] : can't change process group",childPID);
  
			if(loglevel > 1)
				syslog(LOG_INFO,"child server connected. PPID=%d PID=%d GPID=%d\n",getppid(),childPID,getpgid(childPID));    

			close(sockfd);	// child process
			SisIYAServer s(conn,newsockfd,confFile.getInt("ReadTimeout"),sem,loglevel);
			// process the request
			if(s.process() == false)
				syslog(LOG_ERR,"child server(%d) exited with error",childPID);
			else
				if(loglevel > 1)
					syslog(LOG_INFO,"child server(%d) exited succesfully",childPID);
			exit(0);              
		}
		else
			close(newsockfd);	// parent process
	}
}

/*!
The main function.
*/
int main(int argc,char *argv[])
{
	if(argc != 2 ) {
		cerr << "Usage : " << argv[0] << " sisiyad.conf" << endl;
		return 1;
	}
	openlog("sisiyad",LOG_PID,LOG_USER); // Open the syslog. Log progname and pid

	pname=argv[0];
	confFileName=argv[1]; 
	doit();
	return 0;
}
